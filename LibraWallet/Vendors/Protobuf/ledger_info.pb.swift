// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ledger_info.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) The Libra Core Contributors
// SPDX-License-Identifier: Apache-2.0

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

//// Even though we don't always need all hashes, we pass them in and return them
//// always so that we keep them in sync on the client and don't make the client
//// worry about which one(s) to pass in which cases
////
//// This structure serves a dual purpose.
////
//// First, if this structure is signed by 2f+1 validators it signifies the state
//// of the ledger at version `version` -- it contains the transaction
//// accumulator at that version which commits to all historical transactions.
//// This structure may be expanded to include other information that is derived
//// from that accumulator (e.g. the current time according to the time contract)
//// to reduce the number of proofs a client must get.
////
//// Second, the structure contains a `consensus_data_hash` value. This is the
//// hash of an internal data structure that represents a block that is voted on
//// by consensus.
////
//// Combining these two concepts when the consensus algorithm votes on a block B
//// it votes for a LedgerInfo with the `version` being the latest version that
//// will be committed if B gets 2f+1 votes. It sets `consensus_data_hash` to
//// represent B so that if those 2f+1 votes are gathered, the block is valid to
//// commit
struct Types_LedgerInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Current latest version of the system
  var version: UInt64 = 0

  /// Root hash of transaction accumulator at this version
  var transactionAccumulatorHash: Data = SwiftProtobuf.Internal.emptyData

  /// Hash of consensus-specific data that is opaque to all parts of the system
  /// other than consensus.  This is needed to verify signatures because
  /// consensus signing includes this hash
  var consensusDataHash: Data = SwiftProtobuf.Internal.emptyData

  /// The block id of the last committed block corresponding to this ledger info.
  /// This field is not particularly interesting to the clients, but can be used
  /// by the validators for synchronization.
  var consensusBlockID: Data = SwiftProtobuf.Internal.emptyData

  /// Epoch number corresponds to the set of validators that are active for this
  /// ledger info. The main motivation for keeping the epoch number in the
  /// LedgerInfo is to ensure that the client has enough information to verify
  /// that the signatures for this info are coming from the validators that
  /// indeed form a quorum. Without epoch number a potential attack could reuse
  /// the signatures from the validators in one epoch in order to sign the wrong
  /// info belonging to another epoch, in which these validators do not form a
  /// quorum. The very first epoch number is 0.
  var epochNum: UInt64 = 0

  /// Timestamp that represents the microseconds since the epoch (unix time) that is
  /// generated by the proposer of the block.  This is strictly increasing with every block.
  /// If a client reads a timestamp > the one they specified for transaction expiration time,
  /// they can be certain that their transaction will never be included in a block in the future
  /// (assuming that their transaction has not yet been included)
  var timestampUsecs: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

//// The validator node returns this structure which includes signatures
//// from each validator to confirm the state.  The client needs to only pass
//// back the LedgerInfo element since the validator node doesn't need to know
//// the signatures again when the client performs a query, those are only there
//// for the client to be able to verify the state
struct Types_LedgerInfoWithSignatures {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Signatures of the root node from each validator
  var signatures: [Types_ValidatorSignature] {
    get {return _storage._signatures}
    set {_uniqueStorage()._signatures = newValue}
  }

  var ledgerInfo: Types_LedgerInfo {
    get {return _storage._ledgerInfo ?? Types_LedgerInfo()}
    set {_uniqueStorage()._ledgerInfo = newValue}
  }
  /// Returns true if `ledgerInfo` has been explicitly set.
  var hasLedgerInfo: Bool {return _storage._ledgerInfo != nil}
  /// Clears the value of `ledgerInfo`. Subsequent reads from it will return its default value.
  mutating func clearLedgerInfo() {_storage._ledgerInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Types_ValidatorSignature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The account address of the validator, which can be used for retrieving its
  /// public key during the given epoch.
  var validatorID: Data = SwiftProtobuf.Internal.emptyData

  var signature: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "types"

extension Types_LedgerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LedgerInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "transaction_accumulator_hash"),
    3: .standard(proto: "consensus_data_hash"),
    4: .standard(proto: "consensus_block_id"),
    5: .standard(proto: "epoch_num"),
    6: .standard(proto: "timestamp_usecs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.version)
      case 2: try decoder.decodeSingularBytesField(value: &self.transactionAccumulatorHash)
      case 3: try decoder.decodeSingularBytesField(value: &self.consensusDataHash)
      case 4: try decoder.decodeSingularBytesField(value: &self.consensusBlockID)
      case 5: try decoder.decodeSingularUInt64Field(value: &self.epochNum)
      case 6: try decoder.decodeSingularUInt64Field(value: &self.timestampUsecs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularUInt64Field(value: self.version, fieldNumber: 1)
    }
    if !self.transactionAccumulatorHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.transactionAccumulatorHash, fieldNumber: 2)
    }
    if !self.consensusDataHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.consensusDataHash, fieldNumber: 3)
    }
    if !self.consensusBlockID.isEmpty {
      try visitor.visitSingularBytesField(value: self.consensusBlockID, fieldNumber: 4)
    }
    if self.epochNum != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochNum, fieldNumber: 5)
    }
    if self.timestampUsecs != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestampUsecs, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Types_LedgerInfo) -> Bool {
    if self.version != other.version {return false}
    if self.transactionAccumulatorHash != other.transactionAccumulatorHash {return false}
    if self.consensusDataHash != other.consensusDataHash {return false}
    if self.consensusBlockID != other.consensusBlockID {return false}
    if self.epochNum != other.epochNum {return false}
    if self.timestampUsecs != other.timestampUsecs {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Types_LedgerInfoWithSignatures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LedgerInfoWithSignatures"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signatures"),
    2: .standard(proto: "ledger_info"),
  ]

  fileprivate class _StorageClass {
    var _signatures: [Types_ValidatorSignature] = []
    var _ledgerInfo: Types_LedgerInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _signatures = source._signatures
      _ledgerInfo = source._ledgerInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._signatures)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._ledgerInfo)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._signatures.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._signatures, fieldNumber: 1)
      }
      if let v = _storage._ledgerInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Types_LedgerInfoWithSignatures) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._signatures != other_storage._signatures {return false}
        if _storage._ledgerInfo != other_storage._ledgerInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Types_ValidatorSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValidatorSignature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "validator_id"),
    2: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.validatorID)
      case 2: try decoder.decodeSingularBytesField(value: &self.signature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.validatorID.isEmpty {
      try visitor.visitSingularBytesField(value: self.validatorID, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Types_ValidatorSignature) -> Bool {
    if self.validatorID != other.validatorID {return false}
    if self.signature != other.signature {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
