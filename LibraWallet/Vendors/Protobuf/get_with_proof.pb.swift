// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: get_with_proof.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) The Libra Core Contributors
// SPDX-License-Identifier: Apache-2.0

// This file contains proto definitions for performing queries and getting back
// results with proofs.  This is the interface for a client to query data from
// the system. Every query result must include proof so that a client can be
// certain that the data returned is valid.  A client must verify this proof to
// ensure that a node isn't lying to them.

/// How to verify the response as a client:
/// (Note that every response comes in the form of GetWithProofResponse which
/// wraps the inner response elements that correspond to the specific request
/// types.  Below we will assume a single request/response type.  The
/// verification can be extended as needed for multiple types. Also note that we
/// will use the following notation: resp = GetWithProofResponse and req =
/// GetWithProofRequest). Also note that the following will be considered
/// equivalent for brevity: req.requested_items.get_account_state_request ==
/// req.get_account_state_request And, resp.values.get_account_state_response ==
/// resp.get_account_state_response
///
/// GetAccountStateResponse:
/// - let state_req = req.requested_items.get_account_state_request;
/// - let state_resp = resp.values.get_account_state_response;
/// - Verify that:
///      - state_req.access_path == state_resp.access_path
///          - This ensures that the server is responding with the correct access
///          path
/// - let state_data_hash = Hash(state_resp.value);
/// - let state_proof = resp.values.proof.state_proof_value.sparse_merkle_proof;
/// - Validate state_proof using state_data_hash as the leaf
///      - When verifying the state tree, use:
///          state_root_hash = resp.values.transaction_info.state_root_hash
/// - Validate accumulator using resp.values.transaction_info as the leaf
///      - When verifying the accumulator, use:
///          root_hash =
///          resp.ledger_info_with_sigs.ledger_info.ledger_info.txn_root_hash;
/// - Validate that the transaction root hash submitted in
/// req.known_value.node_value.txn_root_hash
///      exists in the proof for accumulator and that the proof is valid with
///      this hash
/// - Validate ledger info
///      - let ledger_info_hash =
///      Hash(resp.ledger_info_with_sigs.ledger_info.ledger_info);
///      - Verify signatures from resp.ledger_info_with_sigs.signatures are
///      signing
///          ledger_info_hash and that there are >2/3 nodes signing this
///          correctly
///      - Validate that the timestamp is relatively recent in
///          resp.ledger_info_with_sigs.ledger_info.timestamp
///
///
/// GetAccountTransactionBySequenceNumberResponse:
/// - Note that other than type completed_transaction, there will be no proof
/// returned
///      since the transaction has not yet been committed.  To ensure that a
///      validator is telling the truth about it not being committed yet, a
///      client should query for their account state and verify that their
///      current sequence number is less than what they are searching for with
///      GetAccountTransactionBySequenceNumberResponse
/// - let txn =
///      resp.get_account_transaction_by_sequence_number_response.transaction.committed_transaction;
/// - let txn_hash = Hash(txn);
/// - Verify that resp.proof.transaction_info.signed_transaction_hash == txn_hash
/// - Validate accumulator using resp.proof.transaction_info as the leaf
///      - When verifying the accumulator, use:
///          root_hash =
///          resp.ledger_info_with_sigs.ledger_info.ledger_info.txn_root_hash;
/// - Validate that the transaction root hash submitted in
/// req.known_value.node_value.txn_root_hash
///      exists in the proof for accumulator and that the proof is valid with
///      this hash
/// - Validate ledger info
///      - let ledger_info_hash =
///      Hash(resp.ledger_info_with_sigs.ledger_info.ledger_info);
///      - Verify signatures from resp.ledger_info_with_sigs.signatures are
///      signing
///          ledger_info_hash and that there are >2/3 nodes signing this
///          correctly
///      - Validate that the timestamp is relatively recent in
///          resp.ledger_info_with_sigs.ledger_info.timestamp
///
///
/// GetTransactionsResponse:
/// - for txn in resp.get_transactions_response.transactions:
///      - let txn = txn.committed_transaction;
///      - let txn_hash = Hash(txn);
///      - Verify that txn.proof.transaction_info.signed_transaction_hash ==
///      txn_hash
///      - Validate accumulator using txn.proof.transaction_info as the leaf
///      - When verifying the accumulator, use:
///          root_hash =
///          resp.ledger_info_with_sigs.ledger_info.ledger_info.txn_root_hash;
///      - Verify that transactions are sequential and none are missing
/// - Validate ledger info
///      - let ledger_info_hash =
///      Hash(resp.ledger_info_with_sigs.ledger_info.ledger_info);
///      - Verify signatures from resp.ledger_info_with_sigs.signatures are
///      signing
///          ledger_info_hash and that there are >2/3 nodes signing this
///          correctly
///      - Validate that the timestamp is relatively recent in
///          resp.ledger_info_with_sigs.ledger_info.timestamp
/// - If the number of transactions returned is less than limit for an ascending
/// query
///      or if the requested offset > current version for a descending query,
///      the client should verify that the timestamp in ledger info is relatively
///      recent to determine if it is likely that all transactions available were
///      returned

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// This API is used to update the client to the latest ledger version and
/// optionally also request 1..n other pieces of data.  This allows for batch
/// queries.  All queries return proofs that a client should check to validate
/// the data.
///
/// Note that if a client only wishes to update to the latest LedgerInfo and
/// receive the proof that this latest ledger extends the client_known_version
/// ledger the client had, they can simply set the requested_items to an empty
/// list.
struct Types_UpdateToLatestLedgerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is the version the client already trusts. Usually the client should
  /// set this to the version it obtained the last time it synced with the
  /// chain. If this is the first time ever the client sends a request, it must
  /// use the waypoint hard-coded in its software.
  var clientKnownVersion: UInt64 = 0

  /// The items for which we are requesting data in this API call.
  var requestedItems: [Types_RequestItem] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_RequestItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestedItems: OneOf_RequestedItems? {
    get {return _storage._requestedItems}
    set {_uniqueStorage()._requestedItems = newValue}
  }

  var getAccountStateRequest: Types_GetAccountStateRequest {
    get {
      if case .getAccountStateRequest(let v)? = _storage._requestedItems {return v}
      return Types_GetAccountStateRequest()
    }
    set {_uniqueStorage()._requestedItems = .getAccountStateRequest(newValue)}
  }

  var getAccountTransactionBySequenceNumberRequest: Types_GetAccountTransactionBySequenceNumberRequest {
    get {
      if case .getAccountTransactionBySequenceNumberRequest(let v)? = _storage._requestedItems {return v}
      return Types_GetAccountTransactionBySequenceNumberRequest()
    }
    set {_uniqueStorage()._requestedItems = .getAccountTransactionBySequenceNumberRequest(newValue)}
  }

  var getEventsByEventAccessPathRequest: Types_GetEventsByEventAccessPathRequest {
    get {
      if case .getEventsByEventAccessPathRequest(let v)? = _storage._requestedItems {return v}
      return Types_GetEventsByEventAccessPathRequest()
    }
    set {_uniqueStorage()._requestedItems = .getEventsByEventAccessPathRequest(newValue)}
  }

  var getTransactionsRequest: Types_GetTransactionsRequest {
    get {
      if case .getTransactionsRequest(let v)? = _storage._requestedItems {return v}
      return Types_GetTransactionsRequest()
    }
    set {_uniqueStorage()._requestedItems = .getTransactionsRequest(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_RequestedItems: Equatable {
    case getAccountStateRequest(Types_GetAccountStateRequest)
    case getAccountTransactionBySequenceNumberRequest(Types_GetAccountTransactionBySequenceNumberRequest)
    case getEventsByEventAccessPathRequest(Types_GetEventsByEventAccessPathRequest)
    case getTransactionsRequest(Types_GetTransactionsRequest)

    static func ==(lhs: Types_RequestItem.OneOf_RequestedItems, rhs: Types_RequestItem.OneOf_RequestedItems) -> Bool {
      switch (lhs, rhs) {
      case (.getAccountStateRequest(let l), .getAccountStateRequest(let r)): return l == r
      case (.getAccountTransactionBySequenceNumberRequest(let l), .getAccountTransactionBySequenceNumberRequest(let r)): return l == r
      case (.getEventsByEventAccessPathRequest(let l), .getEventsByEventAccessPathRequest(let r)): return l == r
      case (.getTransactionsRequest(let l), .getTransactionsRequest(let r)): return l == r
      default: return false
      }
    }
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Response from getting latest ledger
struct Types_UpdateToLatestLedgerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Responses to the queries posed by the requests. The proofs generated will
  /// be relative to the version of the latest ledger provided below.
  var responseItems: [Types_ResponseItem] {
    get {return _storage._responseItems}
    set {_uniqueStorage()._responseItems = newValue}
  }

  /// The latest ledger info this node has. It will come with at least 2f+1
  /// validator signatures as well as a proof that shows the latest ledger
  /// extends the old ledger the client had.
  var ledgerInfoWithSigs: Types_LedgerInfoWithSignatures {
    get {return _storage._ledgerInfoWithSigs ?? Types_LedgerInfoWithSignatures()}
    set {_uniqueStorage()._ledgerInfoWithSigs = newValue}
  }
  /// Returns true if `ledgerInfoWithSigs` has been explicitly set.
  var hasLedgerInfoWithSigs: Bool {return _storage._ledgerInfoWithSigs != nil}
  /// Clears the value of `ledgerInfoWithSigs`. Subsequent reads from it will return its default value.
  mutating func clearLedgerInfoWithSigs() {_storage._ledgerInfoWithSigs = nil}

  /// Validator change events from what the client last knew.  This is used to
  /// inform the client of validator changes from the client's last known version
  /// until the current version
  var validatorChangeEvents: [Types_ValidatorChangeEventWithProof] {
    get {return _storage._validatorChangeEvents}
    set {_uniqueStorage()._validatorChangeEvents = newValue}
  }

  /// A proof that shows the latest ledger accumulator is consistent with the
  /// old accumulator at "client_known_version".
  var ledgerConsistencyProof: Types_AccumulatorConsistencyProof {
    get {return _storage._ledgerConsistencyProof ?? Types_AccumulatorConsistencyProof()}
    set {_uniqueStorage()._ledgerConsistencyProof = newValue}
  }
  /// Returns true if `ledgerConsistencyProof` has been explicitly set.
  var hasLedgerConsistencyProof: Bool {return _storage._ledgerConsistencyProof != nil}
  /// Clears the value of `ledgerConsistencyProof`. Subsequent reads from it will return its default value.
  mutating func clearLedgerConsistencyProof() {_storage._ledgerConsistencyProof = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Individual response items to the queries posed by the requests
struct Types_ResponseItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var responseItems: OneOf_ResponseItems? {
    get {return _storage._responseItems}
    set {_uniqueStorage()._responseItems = newValue}
  }

  var getAccountStateResponse: Types_GetAccountStateResponse {
    get {
      if case .getAccountStateResponse(let v)? = _storage._responseItems {return v}
      return Types_GetAccountStateResponse()
    }
    set {_uniqueStorage()._responseItems = .getAccountStateResponse(newValue)}
  }

  var getAccountTransactionBySequenceNumberResponse: Types_GetAccountTransactionBySequenceNumberResponse {
    get {
      if case .getAccountTransactionBySequenceNumberResponse(let v)? = _storage._responseItems {return v}
      return Types_GetAccountTransactionBySequenceNumberResponse()
    }
    set {_uniqueStorage()._responseItems = .getAccountTransactionBySequenceNumberResponse(newValue)}
  }

  var getEventsByEventAccessPathResponse: Types_GetEventsByEventAccessPathResponse {
    get {
      if case .getEventsByEventAccessPathResponse(let v)? = _storage._responseItems {return v}
      return Types_GetEventsByEventAccessPathResponse()
    }
    set {_uniqueStorage()._responseItems = .getEventsByEventAccessPathResponse(newValue)}
  }

  var getTransactionsResponse: Types_GetTransactionsResponse {
    get {
      if case .getTransactionsResponse(let v)? = _storage._responseItems {return v}
      return Types_GetTransactionsResponse()
    }
    set {_uniqueStorage()._responseItems = .getTransactionsResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ResponseItems: Equatable {
    case getAccountStateResponse(Types_GetAccountStateResponse)
    case getAccountTransactionBySequenceNumberResponse(Types_GetAccountTransactionBySequenceNumberResponse)
    case getEventsByEventAccessPathResponse(Types_GetEventsByEventAccessPathResponse)
    case getTransactionsResponse(Types_GetTransactionsResponse)

    static func ==(lhs: Types_ResponseItem.OneOf_ResponseItems, rhs: Types_ResponseItem.OneOf_ResponseItems) -> Bool {
      switch (lhs, rhs) {
      case (.getAccountStateResponse(let l), .getAccountStateResponse(let r)): return l == r
      case (.getAccountTransactionBySequenceNumberResponse(let l), .getAccountTransactionBySequenceNumberResponse(let r)): return l == r
      case (.getEventsByEventAccessPathResponse(let l), .getEventsByEventAccessPathResponse(let r)): return l == r
      case (.getTransactionsResponse(let l), .getTransactionsResponse(let r)): return l == r
      default: return false
      }
    }
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Gets latest state for an account.
struct Types_GetAccountStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Account for which we are fetching the state.
  var address: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// State information returned by a get account state query.
struct Types_GetAccountStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Blob value representing the account state together with proof the client
  /// can utilize to verify it.
  var accountStateWithProof: Types_AccountStateWithProof {
    get {return _storage._accountStateWithProof ?? Types_AccountStateWithProof()}
    set {_uniqueStorage()._accountStateWithProof = newValue}
  }
  /// Returns true if `accountStateWithProof` has been explicitly set.
  var hasAccountStateWithProof: Bool {return _storage._accountStateWithProof != nil}
  /// Clears the value of `accountStateWithProof`. Subsequent reads from it will return its default value.
  mutating func clearAccountStateWithProof() {_storage._accountStateWithProof = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// -----------------------------------------------------------------------------
/// ---------------- Get single transaction by account + sequence number
/// -----------------------------------------------------------------------------
/// Get transactions that altered an account - this includes both sent and
/// received. A user of this should check that the data returned matches what
/// they expect.  As an example, a potential attack vector would be something
/// like the following: Alice is buying an apple from Bob. Alice's phone signs a
/// transaction X with sequence number N that pays coins to Bob. Alice transmits
/// this signature to Bob's payment terminal which then submits the transaction
/// and checks its status to see if Alice can be given the apple. However, as Bob
/// is doing this Alice constructs a second transaction X' also with sequence
/// number N. Alice gets that transaction inserted in the blockchain. If Bob
/// isn't thoughtful about how he uses this API he may assume that if he asks for
/// the N'th transaction on Alice's account that when the API returns that this
/// means the transaction has gone through. The point here is that one should be
/// careful in reading too much into "transaction X is on the chain" and focus on
/// the logs, which tell you what the transaction did.
///
/// If a client submitted a transaction, they should also verify that the hash of
/// the returned transaction matches what they submitted.  As an example, if a
/// client has two wallets that share the same account, they may both submit a
/// transaction at the same sequence number and only one will be committed.  A
/// client should never assume that if they receive the response that this
/// transaction was included that it means that this is definitely the
/// transaction that was submitted.  They should check that the hash matches what
/// they sent
struct Types_GetAccountTransactionBySequenceNumberRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Account for which to query transactions
  var account: Data = SwiftProtobuf.Internal.emptyData

  var sequenceNumber: UInt64 = 0

  /// Set to true to fetch events for the transaction at this version
  var fetchEvents: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Transaction information for transactions requested by
/// GetAccountTransactionsRequest
struct Types_GetAccountTransactionBySequenceNumberResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// When the transaction requested is committed, return the committed
  /// transaction with proof.
  var signedTransactionWithProof: Types_SignedTransactionWithProof {
    get {return _storage._signedTransactionWithProof ?? Types_SignedTransactionWithProof()}
    set {_uniqueStorage()._signedTransactionWithProof = newValue}
  }
  /// Returns true if `signedTransactionWithProof` has been explicitly set.
  var hasSignedTransactionWithProof: Bool {return _storage._signedTransactionWithProof != nil}
  /// Clears the value of `signedTransactionWithProof`. Subsequent reads from it will return its default value.
  mutating func clearSignedTransactionWithProof() {_storage._signedTransactionWithProof = nil}

  /// When the transaction requested is not committed, we give a proof that
  /// shows the current sequence number is smaller than what would have been if
  /// the transaction was committed.
  var proofOfCurrentSequenceNumber: Types_AccountStateWithProof {
    get {return _storage._proofOfCurrentSequenceNumber ?? Types_AccountStateWithProof()}
    set {_uniqueStorage()._proofOfCurrentSequenceNumber = newValue}
  }
  /// Returns true if `proofOfCurrentSequenceNumber` has been explicitly set.
  var hasProofOfCurrentSequenceNumber: Bool {return _storage._proofOfCurrentSequenceNumber != nil}
  /// Clears the value of `proofOfCurrentSequenceNumber`. Subsequent reads from it will return its default value.
  mutating func clearProofOfCurrentSequenceNumber() {_storage._proofOfCurrentSequenceNumber = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Get events that exist on an event access path.  In the current world,
/// a user may specify events that were received, events that were sent, or any
/// event that modifies their account
struct Types_GetEventsByEventAccessPathRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accessPath: Types_AccessPath {
    get {return _storage._accessPath ?? Types_AccessPath()}
    set {_uniqueStorage()._accessPath = newValue}
  }
  /// Returns true if `accessPath` has been explicitly set.
  var hasAccessPath: Bool {return _storage._accessPath != nil}
  /// Clears the value of `accessPath`. Subsequent reads from it will return its default value.
  mutating func clearAccessPath() {_storage._accessPath = nil}

  /// The sequence number of the event to start with for this query. Use a
  /// sequence number of MAX_INT to represent the latest.
  var startEventSeqNum: UInt64 {
    get {return _storage._startEventSeqNum}
    set {_uniqueStorage()._startEventSeqNum = newValue}
  }

  /// If ascending is true this query will return up to `limit` events that were
  /// emitted after `start_event_seq_num`. Otherwise it will return up to `limit`
  /// events before the offset. Both cases are inclusive.
  var ascending: Bool {
    get {return _storage._ascending}
    set {_uniqueStorage()._ascending = newValue}
  }

  /// Limit number of results
  var limit: UInt64 {
    get {return _storage._limit}
    set {_uniqueStorage()._limit = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Types_GetEventsByEventAccessPathResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Returns an event and proof of each of the events in the request. The first
  /// element of proofs will be the closest to `start_event_seq_num`.
  var eventsWithProof: [Types_EventWithProof] {
    get {return _storage._eventsWithProof}
    set {_uniqueStorage()._eventsWithProof = newValue}
  }

  /// If the number of events returned is less than `limit` for an ascending
  /// query or if start_event_seq_num > the latest seq_num for a descending
  /// query,  returns the state of the account containing the given access path
  /// in the latest state. This allows the client to verify that there are in
  /// fact no extra events.
  ///
  /// The LedgerInfoWithSignatures which is on the main
  /// UpdateToLatestLedgerResponse can be used to validate this.
  var proofOfLatestEvent: Types_AccountStateWithProof {
    get {return _storage._proofOfLatestEvent ?? Types_AccountStateWithProof()}
    set {_uniqueStorage()._proofOfLatestEvent = newValue}
  }
  /// Returns true if `proofOfLatestEvent` has been explicitly set.
  var hasProofOfLatestEvent: Bool {return _storage._proofOfLatestEvent != nil}
  /// Clears the value of `proofOfLatestEvent`. Subsequent reads from it will return its default value.
  mutating func clearProofOfLatestEvent() {_storage._proofOfLatestEvent = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Get up to limit transactions starting from start_version.
struct Types_GetTransactionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The version of the transaction to start with for this query.  Use a version
  /// of MAX_INT to represent the latest.
  var startVersion: UInt64 = 0

  /// Limit number of results
  var limit: UInt64 = 0

  /// Set to true to fetch events for the transaction at each version
  var fetchEvents: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_GetTransactionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txnListWithProof: Types_TransactionListWithProof {
    get {return _storage._txnListWithProof ?? Types_TransactionListWithProof()}
    set {_uniqueStorage()._txnListWithProof = newValue}
  }
  /// Returns true if `txnListWithProof` has been explicitly set.
  var hasTxnListWithProof: Bool {return _storage._txnListWithProof != nil}
  /// Clears the value of `txnListWithProof`. Subsequent reads from it will return its default value.
  mutating func clearTxnListWithProof() {_storage._txnListWithProof = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "types"

extension Types_UpdateToLatestLedgerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateToLatestLedgerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_known_version"),
    2: .standard(proto: "requested_items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.clientKnownVersion)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.requestedItems)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clientKnownVersion != 0 {
      try visitor.visitSingularUInt64Field(value: self.clientKnownVersion, fieldNumber: 1)
    }
    if !self.requestedItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requestedItems, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Types_UpdateToLatestLedgerRequest) -> Bool {
    if self.clientKnownVersion != other.clientKnownVersion {return false}
    if self.requestedItems != other.requestedItems {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Types_RequestItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "get_account_state_request"),
    2: .standard(proto: "get_account_transaction_by_sequence_number_request"),
    3: .standard(proto: "get_events_by_event_access_path_request"),
    4: .standard(proto: "get_transactions_request"),
  ]

  fileprivate class _StorageClass {
    var _requestedItems: Types_RequestItem.OneOf_RequestedItems?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _requestedItems = source._requestedItems
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Types_GetAccountStateRequest?
          if let current = _storage._requestedItems {
            try decoder.handleConflictingOneOf()
            if case .getAccountStateRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._requestedItems = .getAccountStateRequest(v)}
        case 2:
          var v: Types_GetAccountTransactionBySequenceNumberRequest?
          if let current = _storage._requestedItems {
            try decoder.handleConflictingOneOf()
            if case .getAccountTransactionBySequenceNumberRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._requestedItems = .getAccountTransactionBySequenceNumberRequest(v)}
        case 3:
          var v: Types_GetEventsByEventAccessPathRequest?
          if let current = _storage._requestedItems {
            try decoder.handleConflictingOneOf()
            if case .getEventsByEventAccessPathRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._requestedItems = .getEventsByEventAccessPathRequest(v)}
        case 4:
          var v: Types_GetTransactionsRequest?
          if let current = _storage._requestedItems {
            try decoder.handleConflictingOneOf()
            if case .getTransactionsRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._requestedItems = .getTransactionsRequest(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._requestedItems {
      case .getAccountStateRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .getAccountTransactionBySequenceNumberRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .getEventsByEventAccessPathRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .getTransactionsRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Types_RequestItem) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._requestedItems != other_storage._requestedItems {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Types_UpdateToLatestLedgerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateToLatestLedgerResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "response_items"),
    2: .standard(proto: "ledger_info_with_sigs"),
    3: .standard(proto: "validator_change_events"),
    4: .standard(proto: "ledger_consistency_proof"),
  ]

  fileprivate class _StorageClass {
    var _responseItems: [Types_ResponseItem] = []
    var _ledgerInfoWithSigs: Types_LedgerInfoWithSignatures? = nil
    var _validatorChangeEvents: [Types_ValidatorChangeEventWithProof] = []
    var _ledgerConsistencyProof: Types_AccumulatorConsistencyProof? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _responseItems = source._responseItems
      _ledgerInfoWithSigs = source._ledgerInfoWithSigs
      _validatorChangeEvents = source._validatorChangeEvents
      _ledgerConsistencyProof = source._ledgerConsistencyProof
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._responseItems)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._ledgerInfoWithSigs)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._validatorChangeEvents)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._ledgerConsistencyProof)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._responseItems.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._responseItems, fieldNumber: 1)
      }
      if let v = _storage._ledgerInfoWithSigs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._validatorChangeEvents.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._validatorChangeEvents, fieldNumber: 3)
      }
      if let v = _storage._ledgerConsistencyProof {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Types_UpdateToLatestLedgerResponse) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._responseItems != other_storage._responseItems {return false}
        if _storage._ledgerInfoWithSigs != other_storage._ledgerInfoWithSigs {return false}
        if _storage._validatorChangeEvents != other_storage._validatorChangeEvents {return false}
        if _storage._ledgerConsistencyProof != other_storage._ledgerConsistencyProof {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Types_ResponseItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "get_account_state_response"),
    4: .standard(proto: "get_account_transaction_by_sequence_number_response"),
    5: .standard(proto: "get_events_by_event_access_path_response"),
    6: .standard(proto: "get_transactions_response"),
  ]

  fileprivate class _StorageClass {
    var _responseItems: Types_ResponseItem.OneOf_ResponseItems?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _responseItems = source._responseItems
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 3:
          var v: Types_GetAccountStateResponse?
          if let current = _storage._responseItems {
            try decoder.handleConflictingOneOf()
            if case .getAccountStateResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._responseItems = .getAccountStateResponse(v)}
        case 4:
          var v: Types_GetAccountTransactionBySequenceNumberResponse?
          if let current = _storage._responseItems {
            try decoder.handleConflictingOneOf()
            if case .getAccountTransactionBySequenceNumberResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._responseItems = .getAccountTransactionBySequenceNumberResponse(v)}
        case 5:
          var v: Types_GetEventsByEventAccessPathResponse?
          if let current = _storage._responseItems {
            try decoder.handleConflictingOneOf()
            if case .getEventsByEventAccessPathResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._responseItems = .getEventsByEventAccessPathResponse(v)}
        case 6:
          var v: Types_GetTransactionsResponse?
          if let current = _storage._responseItems {
            try decoder.handleConflictingOneOf()
            if case .getTransactionsResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._responseItems = .getTransactionsResponse(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._responseItems {
      case .getAccountStateResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .getAccountTransactionBySequenceNumberResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .getEventsByEventAccessPathResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .getTransactionsResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Types_ResponseItem) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._responseItems != other_storage._responseItems {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Types_GetAccountStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountStateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.address)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Types_GetAccountStateRequest) -> Bool {
    if self.address != other.address {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Types_GetAccountStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_state_with_proof"),
  ]

  fileprivate class _StorageClass {
    var _accountStateWithProof: Types_AccountStateWithProof? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _accountStateWithProof = source._accountStateWithProof
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._accountStateWithProof)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._accountStateWithProof {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Types_GetAccountStateResponse) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._accountStateWithProof != other_storage._accountStateWithProof {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Types_GetAccountTransactionBySequenceNumberRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountTransactionBySequenceNumberRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .standard(proto: "sequence_number"),
    3: .standard(proto: "fetch_events"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.account)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.sequenceNumber)
      case 3: try decoder.decodeSingularBoolField(value: &self.fetchEvents)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularBytesField(value: self.account, fieldNumber: 1)
    }
    if self.sequenceNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.sequenceNumber, fieldNumber: 2)
    }
    if self.fetchEvents != false {
      try visitor.visitSingularBoolField(value: self.fetchEvents, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Types_GetAccountTransactionBySequenceNumberRequest) -> Bool {
    if self.account != other.account {return false}
    if self.sequenceNumber != other.sequenceNumber {return false}
    if self.fetchEvents != other.fetchEvents {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Types_GetAccountTransactionBySequenceNumberResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountTransactionBySequenceNumberResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "signed_transaction_with_proof"),
    3: .standard(proto: "proof_of_current_sequence_number"),
  ]

  fileprivate class _StorageClass {
    var _signedTransactionWithProof: Types_SignedTransactionWithProof? = nil
    var _proofOfCurrentSequenceNumber: Types_AccountStateWithProof? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _signedTransactionWithProof = source._signedTransactionWithProof
      _proofOfCurrentSequenceNumber = source._proofOfCurrentSequenceNumber
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 2: try decoder.decodeSingularMessageField(value: &_storage._signedTransactionWithProof)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._proofOfCurrentSequenceNumber)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._signedTransactionWithProof {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._proofOfCurrentSequenceNumber {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Types_GetAccountTransactionBySequenceNumberResponse) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._signedTransactionWithProof != other_storage._signedTransactionWithProof {return false}
        if _storage._proofOfCurrentSequenceNumber != other_storage._proofOfCurrentSequenceNumber {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Types_GetEventsByEventAccessPathRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetEventsByEventAccessPathRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_path"),
    2: .standard(proto: "start_event_seq_num"),
    3: .same(proto: "ascending"),
    4: .same(proto: "limit"),
  ]

  fileprivate class _StorageClass {
    var _accessPath: Types_AccessPath? = nil
    var _startEventSeqNum: UInt64 = 0
    var _ascending: Bool = false
    var _limit: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _accessPath = source._accessPath
      _startEventSeqNum = source._startEventSeqNum
      _ascending = source._ascending
      _limit = source._limit
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._accessPath)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._startEventSeqNum)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._ascending)
        case 4: try decoder.decodeSingularUInt64Field(value: &_storage._limit)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._accessPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._startEventSeqNum != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._startEventSeqNum, fieldNumber: 2)
      }
      if _storage._ascending != false {
        try visitor.visitSingularBoolField(value: _storage._ascending, fieldNumber: 3)
      }
      if _storage._limit != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._limit, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Types_GetEventsByEventAccessPathRequest) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._accessPath != other_storage._accessPath {return false}
        if _storage._startEventSeqNum != other_storage._startEventSeqNum {return false}
        if _storage._ascending != other_storage._ascending {return false}
        if _storage._limit != other_storage._limit {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Types_GetEventsByEventAccessPathResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetEventsByEventAccessPathResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "events_with_proof"),
    2: .standard(proto: "proof_of_latest_event"),
  ]

  fileprivate class _StorageClass {
    var _eventsWithProof: [Types_EventWithProof] = []
    var _proofOfLatestEvent: Types_AccountStateWithProof? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _eventsWithProof = source._eventsWithProof
      _proofOfLatestEvent = source._proofOfLatestEvent
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._eventsWithProof)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._proofOfLatestEvent)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._eventsWithProof.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._eventsWithProof, fieldNumber: 1)
      }
      if let v = _storage._proofOfLatestEvent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Types_GetEventsByEventAccessPathResponse) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._eventsWithProof != other_storage._eventsWithProof {return false}
        if _storage._proofOfLatestEvent != other_storage._proofOfLatestEvent {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Types_GetTransactionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTransactionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_version"),
    2: .same(proto: "limit"),
    3: .standard(proto: "fetch_events"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.startVersion)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.limit)
      case 3: try decoder.decodeSingularBoolField(value: &self.fetchEvents)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startVersion != 0 {
      try visitor.visitSingularUInt64Field(value: self.startVersion, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularUInt64Field(value: self.limit, fieldNumber: 2)
    }
    if self.fetchEvents != false {
      try visitor.visitSingularBoolField(value: self.fetchEvents, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Types_GetTransactionsRequest) -> Bool {
    if self.startVersion != other.startVersion {return false}
    if self.limit != other.limit {return false}
    if self.fetchEvents != other.fetchEvents {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Types_GetTransactionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTransactionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "txn_list_with_proof"),
  ]

  fileprivate class _StorageClass {
    var _txnListWithProof: Types_TransactionListWithProof? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _txnListWithProof = source._txnListWithProof
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._txnListWithProof)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._txnListWithProof {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Types_GetTransactionsResponse) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._txnListWithProof != other_storage._txnListWithProof {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
