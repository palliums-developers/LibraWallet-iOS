// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: mempool.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) The Libra Core Contributors
// SPDX-License-Identifier: Apache-2.0

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Mempool_AddTransactionWithValidationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Transaction from a wallet
  var transaction: Types_SignedTransaction {
    get {return _storage._transaction ?? Types_SignedTransaction()}
    set {_uniqueStorage()._transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  var hasTransaction: Bool {return _storage._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  mutating func clearTransaction() {_uniqueStorage()._transaction = nil}

  /// Max amount of gas required to execute the transaction
  /// Without running the program, it is very difficult to determine this number,
  /// so we use the max gas specified by the signed transaction.
  /// This field is still included separately from the signed transaction so that
  /// if we have a better methodology in the future, we can more accurately
  /// specify the max gas.
  var maxGasCost: UInt64 {
    get {return _storage._maxGasCost}
    set {_uniqueStorage()._maxGasCost = newValue}
  }

  /// Latest sequence number of the involved account from state db.
  var latestSequenceNumber: UInt64 {
    get {return _storage._latestSequenceNumber}
    set {_uniqueStorage()._latestSequenceNumber = newValue}
  }

  /// Latest account balance of the involved account from state db.
  var accountBalance: UInt64 {
    get {return _storage._accountBalance}
    set {_uniqueStorage()._accountBalance = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Mempool_AddTransactionWithValidationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ledger version at the time of the transaction submitted. The submitted
  /// transaction will have version bigger than this 'current_version'
  var currentVersion: UInt64 {
    get {return _storage._currentVersion}
    set {_uniqueStorage()._currentVersion = newValue}
  }

  /// The result of the transaction submission
  var status: MempoolStatus_MempoolAddTransactionStatus {
    get {return _storage._status ?? MempoolStatus_MempoolAddTransactionStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// -----------------------------------------------------------------------------
/// ---------------- GetBlock
/// -----------------------------------------------------------------------------
struct Mempool_GetBlockRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var maxBlockSize: UInt64 = 0

  var transactions: [Mempool_TransactionExclusion] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mempool_GetBlockResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var block: Types_SignedTransactionsBlock {
    get {return _storage._block ?? Types_SignedTransactionsBlock()}
    set {_uniqueStorage()._block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  var hasBlock: Bool {return _storage._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  mutating func clearBlock() {_uniqueStorage()._block = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Mempool_TransactionExclusion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: Data = SwiftProtobuf.Internal.emptyData

  var sequenceNumber: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// -----------------------------------------------------------------------------
/// ---------------- CommitTransactions
/// -----------------------------------------------------------------------------
struct Mempool_CommitTransactionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transactions: [Mempool_CommittedTransaction] = []

  /// agreed monotonic timestamp microseconds since the epoch for a committed block
  /// used by Mempool to GC expired transactions
  var blockTimestampUsecs: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mempool_CommitTransactionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mempool_CommittedTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: Data = SwiftProtobuf.Internal.emptyData

  var sequenceNumber: UInt64 = 0

  var isRejected: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// -----------------------------------------------------------------------------
/// ---------------- HealthCheck
/// -----------------------------------------------------------------------------
struct Mempool_HealthCheckRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mempool_HealthCheckResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Indicate whether Mempool is in healthy condition.
  var isHealthy: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "mempool"

extension Mempool_AddTransactionWithValidationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddTransactionWithValidationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
    2: .standard(proto: "max_gas_cost"),
    3: .standard(proto: "latest_sequence_number"),
    4: .standard(proto: "account_balance"),
  ]

  fileprivate class _StorageClass {
    var _transaction: Types_SignedTransaction? = nil
    var _maxGasCost: UInt64 = 0
    var _latestSequenceNumber: UInt64 = 0
    var _accountBalance: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transaction = source._transaction
      _maxGasCost = source._maxGasCost
      _latestSequenceNumber = source._latestSequenceNumber
      _accountBalance = source._accountBalance
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._transaction)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._maxGasCost)
        case 3: try decoder.decodeSingularUInt64Field(value: &_storage._latestSequenceNumber)
        case 4: try decoder.decodeSingularUInt64Field(value: &_storage._accountBalance)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._transaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._maxGasCost != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._maxGasCost, fieldNumber: 2)
      }
      if _storage._latestSequenceNumber != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._latestSequenceNumber, fieldNumber: 3)
      }
      if _storage._accountBalance != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._accountBalance, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mempool_AddTransactionWithValidationRequest, rhs: Mempool_AddTransactionWithValidationRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transaction != rhs_storage._transaction {return false}
        if _storage._maxGasCost != rhs_storage._maxGasCost {return false}
        if _storage._latestSequenceNumber != rhs_storage._latestSequenceNumber {return false}
        if _storage._accountBalance != rhs_storage._accountBalance {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mempool_AddTransactionWithValidationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddTransactionWithValidationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "current_version"),
    2: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _currentVersion: UInt64 = 0
    var _status: MempoolStatus_MempoolAddTransactionStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _currentVersion = source._currentVersion
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._currentVersion)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._currentVersion != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._currentVersion, fieldNumber: 1)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mempool_AddTransactionWithValidationResponse, rhs: Mempool_AddTransactionWithValidationResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._currentVersion != rhs_storage._currentVersion {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mempool_GetBlockRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlockRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_block_size"),
    2: .same(proto: "transactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.maxBlockSize)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.transactions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxBlockSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxBlockSize, fieldNumber: 1)
    }
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mempool_GetBlockRequest, rhs: Mempool_GetBlockRequest) -> Bool {
    if lhs.maxBlockSize != rhs.maxBlockSize {return false}
    if lhs.transactions != rhs.transactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mempool_GetBlockResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlockResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "block"),
  ]

  fileprivate class _StorageClass {
    var _block: Types_SignedTransactionsBlock? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _block = source._block
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._block)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._block {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mempool_GetBlockResponse, rhs: Mempool_GetBlockResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._block != rhs_storage._block {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mempool_TransactionExclusion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionExclusion"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "sequence_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.sender)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.sequenceNumber)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularBytesField(value: self.sender, fieldNumber: 1)
    }
    if self.sequenceNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.sequenceNumber, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mempool_TransactionExclusion, rhs: Mempool_TransactionExclusion) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mempool_CommitTransactionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommitTransactionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactions"),
    2: .standard(proto: "block_timestamp_usecs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.transactions)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.blockTimestampUsecs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 1)
    }
    if self.blockTimestampUsecs != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockTimestampUsecs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mempool_CommitTransactionsRequest, rhs: Mempool_CommitTransactionsRequest) -> Bool {
    if lhs.transactions != rhs.transactions {return false}
    if lhs.blockTimestampUsecs != rhs.blockTimestampUsecs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mempool_CommitTransactionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommitTransactionsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mempool_CommitTransactionsResponse, rhs: Mempool_CommitTransactionsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mempool_CommittedTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommittedTransaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "sequence_number"),
    3: .standard(proto: "is_rejected"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.sender)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.sequenceNumber)
      case 3: try decoder.decodeSingularBoolField(value: &self.isRejected)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularBytesField(value: self.sender, fieldNumber: 1)
    }
    if self.sequenceNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.sequenceNumber, fieldNumber: 2)
    }
    if self.isRejected != false {
      try visitor.visitSingularBoolField(value: self.isRejected, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mempool_CommittedTransaction, rhs: Mempool_CommittedTransaction) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.isRejected != rhs.isRejected {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mempool_HealthCheckRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HealthCheckRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mempool_HealthCheckRequest, rhs: Mempool_HealthCheckRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mempool_HealthCheckResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HealthCheckResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_healthy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.isHealthy)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isHealthy != false {
      try visitor.visitSingularBoolField(value: self.isHealthy, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mempool_HealthCheckResponse, rhs: Mempool_HealthCheckResponse) -> Bool {
    if lhs.isHealthy != rhs.isHealthy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
