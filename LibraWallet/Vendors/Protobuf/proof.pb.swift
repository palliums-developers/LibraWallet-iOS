// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proof.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) The Libra Core Contributors
// SPDX-License-Identifier: Apache-2.0

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Types_AccumulatorProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The siblings. The ones near the leaf are at the beginning of the list. The
  /// placeholder nodes are represented by empty byte arrays, other nodes should
  /// be exactly 32-bytes long.
  var siblings: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_SparseMerkleProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This proof can be used to authenticate whether a given leaf exists in the
  /// tree or not. In Rust:
  ///   - If this is `Some(HashValue, HashValue)`
  ///     - If the first `HashValue` equals requested key, this is an inclusion
  ///       proof and the second `HashValue` equals the hash of the
  ///       corresponding account blob.
  ///     - Otherwise this is a non-inclusion proof. The first `HashValue` is
  ///       the only key that exists in the subtree and the second `HashValue`
  ///       equals the hash of the corresponding account blob.
  ///   - If this is `None`, this is also a non-inclusion proof which indicates
  ///     the subtree is empty.
  ///
  /// In protobuf, this leaf field should either be
  ///   - empty, which corresponds to None in the Rust structure.
  ///   - exactly 64 bytes, which corresponds to Some<(HashValue, HashValue)>
  ///     in the Rust structure.
  var leaf: Data = SwiftProtobuf.Internal.emptyData

  /// The siblings. The ones near the leaf are at the beginning of the list. The
  /// placeholder nodes are represented by empty byte arrays, other nodes should
  /// be exactly 32-bytes long.
  var siblings: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_AccumulatorConsistencyProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The root hashes of the subtrees that represent new leaves. Note that none
  /// of these hashes should be default hash.
  var subtrees: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_AccumulatorRangeProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The siblings on the left of the path from root to the first leaf. The ones
  /// near the leaf are at the beginning of the list. The placeholder nodes are
  /// represented by empty byte arrays, other nodes should be exactly 32-bytes
  /// long.
  var leftSiblings: [Data] = []

  /// The siblings on the right of the path from root to the last leaf. The ones
  /// near the leaf are at the beginning of the list. The placeholder nodes are
  /// represented by empty byte arrays, other nodes should be exactly 32-bytes
  /// long.
  var rightSiblings: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_SparseMerkleRangeProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The siblings on the right of the path from root to the last leaf. The ones
  /// near the leaf are at the beginning of the list. The placeholder nodes are
  /// represented by empty byte arrays, other nodes should be exactly 32-bytes
  /// long.
  var rightSiblings: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The complete proof used to authenticate a transaction.
struct Types_TransactionProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ledgerInfoToTransactionInfoProof: Types_AccumulatorProof {
    get {return _storage._ledgerInfoToTransactionInfoProof ?? Types_AccumulatorProof()}
    set {_uniqueStorage()._ledgerInfoToTransactionInfoProof = newValue}
  }
  /// Returns true if `ledgerInfoToTransactionInfoProof` has been explicitly set.
  var hasLedgerInfoToTransactionInfoProof: Bool {return _storage._ledgerInfoToTransactionInfoProof != nil}
  /// Clears the value of `ledgerInfoToTransactionInfoProof`. Subsequent reads from it will return its default value.
  mutating func clearLedgerInfoToTransactionInfoProof() {_uniqueStorage()._ledgerInfoToTransactionInfoProof = nil}

  var transactionInfo: Types_TransactionInfo {
    get {return _storage._transactionInfo ?? Types_TransactionInfo()}
    set {_uniqueStorage()._transactionInfo = newValue}
  }
  /// Returns true if `transactionInfo` has been explicitly set.
  var hasTransactionInfo: Bool {return _storage._transactionInfo != nil}
  /// Clears the value of `transactionInfo`. Subsequent reads from it will return its default value.
  mutating func clearTransactionInfo() {_uniqueStorage()._transactionInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The complete proof used to authenticate an account state.
struct Types_AccountStateProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ledgerInfoToTransactionInfoProof: Types_AccumulatorProof {
    get {return _storage._ledgerInfoToTransactionInfoProof ?? Types_AccumulatorProof()}
    set {_uniqueStorage()._ledgerInfoToTransactionInfoProof = newValue}
  }
  /// Returns true if `ledgerInfoToTransactionInfoProof` has been explicitly set.
  var hasLedgerInfoToTransactionInfoProof: Bool {return _storage._ledgerInfoToTransactionInfoProof != nil}
  /// Clears the value of `ledgerInfoToTransactionInfoProof`. Subsequent reads from it will return its default value.
  mutating func clearLedgerInfoToTransactionInfoProof() {_uniqueStorage()._ledgerInfoToTransactionInfoProof = nil}

  var transactionInfo: Types_TransactionInfo {
    get {return _storage._transactionInfo ?? Types_TransactionInfo()}
    set {_uniqueStorage()._transactionInfo = newValue}
  }
  /// Returns true if `transactionInfo` has been explicitly set.
  var hasTransactionInfo: Bool {return _storage._transactionInfo != nil}
  /// Clears the value of `transactionInfo`. Subsequent reads from it will return its default value.
  mutating func clearTransactionInfo() {_uniqueStorage()._transactionInfo = nil}

  var transactionInfoToAccountProof: Types_SparseMerkleProof {
    get {return _storage._transactionInfoToAccountProof ?? Types_SparseMerkleProof()}
    set {_uniqueStorage()._transactionInfoToAccountProof = newValue}
  }
  /// Returns true if `transactionInfoToAccountProof` has been explicitly set.
  var hasTransactionInfoToAccountProof: Bool {return _storage._transactionInfoToAccountProof != nil}
  /// Clears the value of `transactionInfoToAccountProof`. Subsequent reads from it will return its default value.
  mutating func clearTransactionInfoToAccountProof() {_uniqueStorage()._transactionInfoToAccountProof = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The complete proof used to authenticate an event.
struct Types_EventProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ledgerInfoToTransactionInfoProof: Types_AccumulatorProof {
    get {return _storage._ledgerInfoToTransactionInfoProof ?? Types_AccumulatorProof()}
    set {_uniqueStorage()._ledgerInfoToTransactionInfoProof = newValue}
  }
  /// Returns true if `ledgerInfoToTransactionInfoProof` has been explicitly set.
  var hasLedgerInfoToTransactionInfoProof: Bool {return _storage._ledgerInfoToTransactionInfoProof != nil}
  /// Clears the value of `ledgerInfoToTransactionInfoProof`. Subsequent reads from it will return its default value.
  mutating func clearLedgerInfoToTransactionInfoProof() {_uniqueStorage()._ledgerInfoToTransactionInfoProof = nil}

  var transactionInfo: Types_TransactionInfo {
    get {return _storage._transactionInfo ?? Types_TransactionInfo()}
    set {_uniqueStorage()._transactionInfo = newValue}
  }
  /// Returns true if `transactionInfo` has been explicitly set.
  var hasTransactionInfo: Bool {return _storage._transactionInfo != nil}
  /// Clears the value of `transactionInfo`. Subsequent reads from it will return its default value.
  mutating func clearTransactionInfo() {_uniqueStorage()._transactionInfo = nil}

  var transactionInfoToEventProof: Types_AccumulatorProof {
    get {return _storage._transactionInfoToEventProof ?? Types_AccumulatorProof()}
    set {_uniqueStorage()._transactionInfoToEventProof = newValue}
  }
  /// Returns true if `transactionInfoToEventProof` has been explicitly set.
  var hasTransactionInfoToEventProof: Bool {return _storage._transactionInfoToEventProof != nil}
  /// Clears the value of `transactionInfoToEventProof`. Subsequent reads from it will return its default value.
  mutating func clearTransactionInfoToEventProof() {_uniqueStorage()._transactionInfoToEventProof = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The complete proof used to authenticate a list of transactions.
struct Types_TransactionListProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ledgerInfoToTransactionInfosProof: Types_AccumulatorRangeProof {
    get {return _storage._ledgerInfoToTransactionInfosProof ?? Types_AccumulatorRangeProof()}
    set {_uniqueStorage()._ledgerInfoToTransactionInfosProof = newValue}
  }
  /// Returns true if `ledgerInfoToTransactionInfosProof` has been explicitly set.
  var hasLedgerInfoToTransactionInfosProof: Bool {return _storage._ledgerInfoToTransactionInfosProof != nil}
  /// Clears the value of `ledgerInfoToTransactionInfosProof`. Subsequent reads from it will return its default value.
  mutating func clearLedgerInfoToTransactionInfosProof() {_uniqueStorage()._ledgerInfoToTransactionInfosProof = nil}

  var transactionInfos: [Types_TransactionInfo] {
    get {return _storage._transactionInfos}
    set {_uniqueStorage()._transactionInfos = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "types"

extension Types_AccumulatorProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccumulatorProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "siblings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedBytesField(value: &self.siblings)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.siblings.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.siblings, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AccumulatorProof, rhs: Types_AccumulatorProof) -> Bool {
    if lhs.siblings != rhs.siblings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SparseMerkleProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SparseMerkleProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "leaf"),
    2: .same(proto: "siblings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.leaf)
      case 2: try decoder.decodeRepeatedBytesField(value: &self.siblings)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.leaf.isEmpty {
      try visitor.visitSingularBytesField(value: self.leaf, fieldNumber: 1)
    }
    if !self.siblings.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.siblings, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SparseMerkleProof, rhs: Types_SparseMerkleProof) -> Bool {
    if lhs.leaf != rhs.leaf {return false}
    if lhs.siblings != rhs.siblings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AccumulatorConsistencyProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccumulatorConsistencyProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subtrees"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedBytesField(value: &self.subtrees)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subtrees.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.subtrees, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AccumulatorConsistencyProof, rhs: Types_AccumulatorConsistencyProof) -> Bool {
    if lhs.subtrees != rhs.subtrees {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AccumulatorRangeProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccumulatorRangeProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "left_siblings"),
    2: .standard(proto: "right_siblings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedBytesField(value: &self.leftSiblings)
      case 2: try decoder.decodeRepeatedBytesField(value: &self.rightSiblings)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.leftSiblings.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.leftSiblings, fieldNumber: 1)
    }
    if !self.rightSiblings.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.rightSiblings, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AccumulatorRangeProof, rhs: Types_AccumulatorRangeProof) -> Bool {
    if lhs.leftSiblings != rhs.leftSiblings {return false}
    if lhs.rightSiblings != rhs.rightSiblings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SparseMerkleRangeProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SparseMerkleRangeProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "right_siblings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedBytesField(value: &self.rightSiblings)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rightSiblings.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.rightSiblings, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SparseMerkleRangeProof, rhs: Types_SparseMerkleRangeProof) -> Bool {
    if lhs.rightSiblings != rhs.rightSiblings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_TransactionProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ledger_info_to_transaction_info_proof"),
    2: .standard(proto: "transaction_info"),
  ]

  fileprivate class _StorageClass {
    var _ledgerInfoToTransactionInfoProof: Types_AccumulatorProof? = nil
    var _transactionInfo: Types_TransactionInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ledgerInfoToTransactionInfoProof = source._ledgerInfoToTransactionInfoProof
      _transactionInfo = source._transactionInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._ledgerInfoToTransactionInfoProof)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._transactionInfo)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._ledgerInfoToTransactionInfoProof {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._transactionInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_TransactionProof, rhs: Types_TransactionProof) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ledgerInfoToTransactionInfoProof != rhs_storage._ledgerInfoToTransactionInfoProof {return false}
        if _storage._transactionInfo != rhs_storage._transactionInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AccountStateProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountStateProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ledger_info_to_transaction_info_proof"),
    2: .standard(proto: "transaction_info"),
    3: .standard(proto: "transaction_info_to_account_proof"),
  ]

  fileprivate class _StorageClass {
    var _ledgerInfoToTransactionInfoProof: Types_AccumulatorProof? = nil
    var _transactionInfo: Types_TransactionInfo? = nil
    var _transactionInfoToAccountProof: Types_SparseMerkleProof? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ledgerInfoToTransactionInfoProof = source._ledgerInfoToTransactionInfoProof
      _transactionInfo = source._transactionInfo
      _transactionInfoToAccountProof = source._transactionInfoToAccountProof
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._ledgerInfoToTransactionInfoProof)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._transactionInfo)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._transactionInfoToAccountProof)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._ledgerInfoToTransactionInfoProof {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._transactionInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._transactionInfoToAccountProof {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AccountStateProof, rhs: Types_AccountStateProof) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ledgerInfoToTransactionInfoProof != rhs_storage._ledgerInfoToTransactionInfoProof {return false}
        if _storage._transactionInfo != rhs_storage._transactionInfo {return false}
        if _storage._transactionInfoToAccountProof != rhs_storage._transactionInfoToAccountProof {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ledger_info_to_transaction_info_proof"),
    2: .standard(proto: "transaction_info"),
    3: .standard(proto: "transaction_info_to_event_proof"),
  ]

  fileprivate class _StorageClass {
    var _ledgerInfoToTransactionInfoProof: Types_AccumulatorProof? = nil
    var _transactionInfo: Types_TransactionInfo? = nil
    var _transactionInfoToEventProof: Types_AccumulatorProof? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ledgerInfoToTransactionInfoProof = source._ledgerInfoToTransactionInfoProof
      _transactionInfo = source._transactionInfo
      _transactionInfoToEventProof = source._transactionInfoToEventProof
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._ledgerInfoToTransactionInfoProof)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._transactionInfo)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._transactionInfoToEventProof)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._ledgerInfoToTransactionInfoProof {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._transactionInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._transactionInfoToEventProof {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventProof, rhs: Types_EventProof) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ledgerInfoToTransactionInfoProof != rhs_storage._ledgerInfoToTransactionInfoProof {return false}
        if _storage._transactionInfo != rhs_storage._transactionInfo {return false}
        if _storage._transactionInfoToEventProof != rhs_storage._transactionInfoToEventProof {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_TransactionListProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionListProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ledger_info_to_transaction_infos_proof"),
    2: .standard(proto: "transaction_infos"),
  ]

  fileprivate class _StorageClass {
    var _ledgerInfoToTransactionInfosProof: Types_AccumulatorRangeProof? = nil
    var _transactionInfos: [Types_TransactionInfo] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ledgerInfoToTransactionInfosProof = source._ledgerInfoToTransactionInfosProof
      _transactionInfos = source._transactionInfos
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._ledgerInfoToTransactionInfosProof)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._transactionInfos)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._ledgerInfoToTransactionInfosProof {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._transactionInfos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._transactionInfos, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_TransactionListProof, rhs: Types_TransactionListProof) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ledgerInfoToTransactionInfosProof != rhs_storage._ledgerInfoToTransactionInfosProof {return false}
        if _storage._transactionInfos != rhs_storage._transactionInfos {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
