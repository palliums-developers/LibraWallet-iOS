// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: transaction.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) The Libra Core Contributors
// SPDX-License-Identifier: Apache-2.0

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// An argument to the transaction if the transaction takes arguments
struct Types_TransactionArgument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ArgType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case u64 // = 0
    case address // = 1
    case string // = 2
    case bytearray // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .u64
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .u64
      case 1: self = .address
      case 2: self = .string
      case 3: self = .bytearray
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .u64: return 0
      case .address: return 1
      case .string: return 2
      case .bytearray: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Types_TransactionArgument.ArgType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Types_TransactionArgument.ArgType] = [
    .u64,
    .address,
    .string,
    .bytearray,
  ]
}

#endif  // swift(>=4.2)

/// A generic structure that represents signed RawTransaction
struct Types_SignedTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// LCS bytes representation of a SignedTransaction.
  var txnBytes: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A generic structure that represents a transaction, covering all possible
/// variants.
struct Types_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transaction: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_TransactionWithProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The version of the returned signed transaction.
  var version: UInt64 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// The transaction itself.
  var transaction: Types_Transaction {
    get {return _storage._transaction ?? Types_Transaction()}
    set {_uniqueStorage()._transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  var hasTransaction: Bool {return _storage._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  mutating func clearTransaction() {_uniqueStorage()._transaction = nil}

  /// The proof authenticating the transaction.
  var proof: Types_TransactionProof {
    get {return _storage._proof ?? Types_TransactionProof()}
    set {_uniqueStorage()._proof = newValue}
  }
  /// Returns true if `proof` has been explicitly set.
  var hasProof: Bool {return _storage._proof != nil}
  /// Clears the value of `proof`. Subsequent reads from it will return its default value.
  mutating func clearProof() {_uniqueStorage()._proof = nil}

  /// The events yielded by executing the transaction, if requested.
  var events: Types_EventsList {
    get {return _storage._events ?? Types_EventsList()}
    set {_uniqueStorage()._events = newValue}
  }
  /// Returns true if `events` has been explicitly set.
  var hasEvents: Bool {return _storage._events != nil}
  /// Clears the value of `events`. Subsequent reads from it will return its default value.
  mutating func clearEvents() {_uniqueStorage()._events = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A generic structure that represents a block of transactions originated from a
/// particular validator instance.
struct Types_SignedTransactionsBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Set of Signed Transactions
  var transactions: [Types_SignedTransaction] = []

  /// Public key of the validator that created this block
  var validatorPublicKey: Data = SwiftProtobuf.Internal.emptyData

  /// Signature of the validator that created this block
  var validatorSignature: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Account state as a whole.
/// After execution, updates to accounts are passed in this form to storage for
/// persistence.
struct Types_AccountState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Account address
  var address: Data = SwiftProtobuf.Internal.emptyData

  /// Account state blob
  var blob: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Transaction struct to commit to storage
struct Types_TransactionToCommit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The signed transaction which was executed
  var transaction: Types_Transaction {
    get {return _storage._transaction ?? Types_Transaction()}
    set {_uniqueStorage()._transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  var hasTransaction: Bool {return _storage._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  mutating func clearTransaction() {_uniqueStorage()._transaction = nil}

  /// State db updates
  var accountStates: [Types_AccountState] {
    get {return _storage._accountStates}
    set {_uniqueStorage()._accountStates = newValue}
  }

  /// Events yielded by the transaction.
  var events: [Types_Event] {
    get {return _storage._events}
    set {_uniqueStorage()._events = newValue}
  }

  /// The amount of gas used.
  var gasUsed: UInt64 {
    get {return _storage._gasUsed}
    set {_uniqueStorage()._gasUsed = newValue}
  }

  /// The major status of executing the transaction.
  var majorStatus: UInt64 {
    get {return _storage._majorStatus}
    set {_uniqueStorage()._majorStatus = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A list of consecutive transactions with proof. This is mainly used for state
/// synchronization when a validator would request a list of transactions from a
/// peer, verify the proof, execute the transactions and persist them. Note that
/// the transactions are supposed to belong to the same epoch E, otherwise
/// verification will fail.
struct Types_TransactionListWithProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of transactions.
  var transactions: [Types_Transaction] {
    get {return _storage._transactions}
    set {_uniqueStorage()._transactions = newValue}
  }

  /// The list of corresponding Event objects (only present if fetch_events was
  /// set to true in req)
  var eventsForVersions: Types_EventsForVersions {
    get {return _storage._eventsForVersions ?? Types_EventsForVersions()}
    set {_uniqueStorage()._eventsForVersions = newValue}
  }
  /// Returns true if `eventsForVersions` has been explicitly set.
  var hasEventsForVersions: Bool {return _storage._eventsForVersions != nil}
  /// Clears the value of `eventsForVersions`. Subsequent reads from it will return its default value.
  mutating func clearEventsForVersions() {_uniqueStorage()._eventsForVersions = nil}

  /// If the list is not empty, the version of the first transaction.
  var firstTransactionVersion: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _storage._firstTransactionVersion ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_uniqueStorage()._firstTransactionVersion = newValue}
  }
  /// Returns true if `firstTransactionVersion` has been explicitly set.
  var hasFirstTransactionVersion: Bool {return _storage._firstTransactionVersion != nil}
  /// Clears the value of `firstTransactionVersion`. Subsequent reads from it will return its default value.
  mutating func clearFirstTransactionVersion() {_uniqueStorage()._firstTransactionVersion = nil}

  /// The proof authenticating the transactions and events.When this is used
  /// for state synchronization, the validator who requests the transactions
  /// will provide a version in the request and the proofs will be relative to
  /// the given version. When this is returned in GetTransactionsResponse, the
  /// proofs will be relative to the ledger info returned in
  /// UpdateToLatestLedgerResponse.
  var proof: Types_TransactionListProof {
    get {return _storage._proof ?? Types_TransactionListProof()}
    set {_uniqueStorage()._proof = newValue}
  }
  /// Returns true if `proof` has been explicitly set.
  var hasProof: Bool {return _storage._proof != nil}
  /// Clears the value of `proof`. Subsequent reads from it will return its default value.
  mutating func clearProof() {_uniqueStorage()._proof = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "types"

extension Types_TransactionArgument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionArgument"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_TransactionArgument, rhs: Types_TransactionArgument) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_TransactionArgument.ArgType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "U64"),
    1: .same(proto: "ADDRESS"),
    2: .same(proto: "STRING"),
    3: .same(proto: "BYTEARRAY"),
  ]
}

extension Types_SignedTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignedTransaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "txn_bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 5: try decoder.decodeSingularBytesField(value: &self.txnBytes)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txnBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.txnBytes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SignedTransaction, rhs: Types_SignedTransaction) -> Bool {
    if lhs.txnBytes != rhs.txnBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Transaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.transaction)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.transaction, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_Transaction, rhs: Types_Transaction) -> Bool {
    if lhs.transaction != rhs.transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_TransactionWithProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionWithProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "transaction"),
    3: .same(proto: "proof"),
    4: .same(proto: "events"),
  ]

  fileprivate class _StorageClass {
    var _version: UInt64 = 0
    var _transaction: Types_Transaction? = nil
    var _proof: Types_TransactionProof? = nil
    var _events: Types_EventsList? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _version = source._version
      _transaction = source._transaction
      _proof = source._proof
      _events = source._events
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._version)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._transaction)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._proof)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._events)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._version != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._version, fieldNumber: 1)
      }
      if let v = _storage._transaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._proof {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._events {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_TransactionWithProof, rhs: Types_TransactionWithProof) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._version != rhs_storage._version {return false}
        if _storage._transaction != rhs_storage._transaction {return false}
        if _storage._proof != rhs_storage._proof {return false}
        if _storage._events != rhs_storage._events {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SignedTransactionsBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignedTransactionsBlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactions"),
    2: .standard(proto: "validator_public_key"),
    3: .standard(proto: "validator_signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.transactions)
      case 2: try decoder.decodeSingularBytesField(value: &self.validatorPublicKey)
      case 3: try decoder.decodeSingularBytesField(value: &self.validatorSignature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 1)
    }
    if !self.validatorPublicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.validatorPublicKey, fieldNumber: 2)
    }
    if !self.validatorSignature.isEmpty {
      try visitor.visitSingularBytesField(value: self.validatorSignature, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SignedTransactionsBlock, rhs: Types_SignedTransactionsBlock) -> Bool {
    if lhs.transactions != rhs.transactions {return false}
    if lhs.validatorPublicKey != rhs.validatorPublicKey {return false}
    if lhs.validatorSignature != rhs.validatorSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AccountState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "blob"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.address)
      case 2: try decoder.decodeSingularBytesField(value: &self.blob)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if !self.blob.isEmpty {
      try visitor.visitSingularBytesField(value: self.blob, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AccountState, rhs: Types_AccountState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.blob != rhs.blob {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_TransactionToCommit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionToCommit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
    2: .standard(proto: "account_states"),
    3: .same(proto: "events"),
    4: .standard(proto: "gas_used"),
    5: .standard(proto: "major_status"),
  ]

  fileprivate class _StorageClass {
    var _transaction: Types_Transaction? = nil
    var _accountStates: [Types_AccountState] = []
    var _events: [Types_Event] = []
    var _gasUsed: UInt64 = 0
    var _majorStatus: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transaction = source._transaction
      _accountStates = source._accountStates
      _events = source._events
      _gasUsed = source._gasUsed
      _majorStatus = source._majorStatus
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._transaction)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._accountStates)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._events)
        case 4: try decoder.decodeSingularUInt64Field(value: &_storage._gasUsed)
        case 5: try decoder.decodeSingularUInt64Field(value: &_storage._majorStatus)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._transaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._accountStates.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._accountStates, fieldNumber: 2)
      }
      if !_storage._events.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._events, fieldNumber: 3)
      }
      if _storage._gasUsed != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._gasUsed, fieldNumber: 4)
      }
      if _storage._majorStatus != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._majorStatus, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_TransactionToCommit, rhs: Types_TransactionToCommit) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transaction != rhs_storage._transaction {return false}
        if _storage._accountStates != rhs_storage._accountStates {return false}
        if _storage._events != rhs_storage._events {return false}
        if _storage._gasUsed != rhs_storage._gasUsed {return false}
        if _storage._majorStatus != rhs_storage._majorStatus {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_TransactionListWithProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionListWithProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactions"),
    2: .standard(proto: "events_for_versions"),
    3: .standard(proto: "first_transaction_version"),
    4: .same(proto: "proof"),
  ]

  fileprivate class _StorageClass {
    var _transactions: [Types_Transaction] = []
    var _eventsForVersions: Types_EventsForVersions? = nil
    var _firstTransactionVersion: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    var _proof: Types_TransactionListProof? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transactions = source._transactions
      _eventsForVersions = source._eventsForVersions
      _firstTransactionVersion = source._firstTransactionVersion
      _proof = source._proof
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._transactions)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._eventsForVersions)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._firstTransactionVersion)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._proof)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._transactions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._transactions, fieldNumber: 1)
      }
      if let v = _storage._eventsForVersions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._firstTransactionVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._proof {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_TransactionListWithProof, rhs: Types_TransactionListWithProof) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transactions != rhs_storage._transactions {return false}
        if _storage._eventsForVersions != rhs_storage._eventsForVersions {return false}
        if _storage._firstTransactionVersion != rhs_storage._firstTransactionVersion {return false}
        if _storage._proof != rhs_storage._proof {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
