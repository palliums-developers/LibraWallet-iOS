// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: execution.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) The Libra Core Contributors
// SPDX-License-Identifier: Apache-2.0

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Execution_CommitBlockStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// The block is persisted.
  case succeeded // = 0

  /// Something went wrong.
  case failed // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .succeeded
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .succeeded
    case 1: self = .failed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .succeeded: return 0
    case .failed: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

struct Execution_ExecuteBlockRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of transactions from consensus.
  var transactions: [Types_SignedTransaction] = []

  /// Id of the parent block.
  /// We're going to use a special GENESIS_BLOCK_ID constant defined in
  /// crypto::hash module to refer to the block id of the Genesis block, which is
  /// executed in a special way.
  var parentBlockID: Data = SwiftProtobuf.Internal.emptyData

  /// Id of the current block.
  var blockID: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result of transaction execution.
struct Execution_ExecuteBlockResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Root hash of the ledger after applying all the transactions in this
  /// block.
  var rootHash: Data {
    get {return _storage._rootHash}
    set {_uniqueStorage()._rootHash = newValue}
  }

  /// The execution result of the transactions. Each transaction has a status
  /// field that indicates whether it should be included in the ledger once the
  /// block is committed.
  var status: [Types_VMStatus] {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// The corresponding ledger version when this block is committed.
  var version: UInt64 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// If set, this field designates that if this block is committed, then the
  /// next epoch will start immediately with the included set of validators.
  var validators: Types_ValidatorSet {
    get {return _storage._validators ?? Types_ValidatorSet()}
    set {_uniqueStorage()._validators = newValue}
  }
  /// Returns true if `validators` has been explicitly set.
  var hasValidators: Bool {return _storage._validators != nil}
  /// Clears the value of `validators`. Subsequent reads from it will return its default value.
  mutating func clearValidators() {_storage._validators = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Execution_CommitBlockRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ledger info with signatures from 2f+1 validators. It contains the id
  /// of the block consensus wants to commit. This will cause the given block
  /// and all the uncommitted ancestors to be committed to storage.
  var ledgerInfoWithSigs: Types_LedgerInfoWithSignatures {
    get {return _storage._ledgerInfoWithSigs ?? Types_LedgerInfoWithSignatures()}
    set {_uniqueStorage()._ledgerInfoWithSigs = newValue}
  }
  /// Returns true if `ledgerInfoWithSigs` has been explicitly set.
  var hasLedgerInfoWithSigs: Bool {return _storage._ledgerInfoWithSigs != nil}
  /// Clears the value of `ledgerInfoWithSigs`. Subsequent reads from it will return its default value.
  mutating func clearLedgerInfoWithSigs() {_storage._ledgerInfoWithSigs = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Execution_CommitBlockResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Execution_CommitBlockStatus = .succeeded

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Ask Execution service to execute and commit a chunk of contiguous
/// transactions. All the transactions in this chunk should belong to the same
/// epoch E. If the caller has a list of transactions that span two epochs, it
/// should split the transactions.
struct Execution_ExecuteChunkRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txnListWithProof: Types_TransactionListWithProof {
    get {return _storage._txnListWithProof ?? Types_TransactionListWithProof()}
    set {_uniqueStorage()._txnListWithProof = newValue}
  }
  /// Returns true if `txnListWithProof` has been explicitly set.
  var hasTxnListWithProof: Bool {return _storage._txnListWithProof != nil}
  /// Clears the value of `txnListWithProof`. Subsequent reads from it will return its default value.
  mutating func clearTxnListWithProof() {_storage._txnListWithProof = nil}

  var ledgerInfoWithSigs: Types_LedgerInfoWithSignatures {
    get {return _storage._ledgerInfoWithSigs ?? Types_LedgerInfoWithSignatures()}
    set {_uniqueStorage()._ledgerInfoWithSigs = newValue}
  }
  /// Returns true if `ledgerInfoWithSigs` has been explicitly set.
  var hasLedgerInfoWithSigs: Bool {return _storage._ledgerInfoWithSigs != nil}
  /// Clears the value of `ledgerInfoWithSigs`. Subsequent reads from it will return its default value.
  mutating func clearLedgerInfoWithSigs() {_storage._ledgerInfoWithSigs = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Either all transactions are successfully executed and persisted, or nothing
/// happens.
struct Execution_ExecuteChunkResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "execution"

extension Execution_CommitBlockStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUCCEEDED"),
    1: .same(proto: "FAILED"),
  ]
}

extension Execution_ExecuteBlockRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecuteBlockRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactions"),
    2: .standard(proto: "parent_block_id"),
    3: .standard(proto: "block_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.transactions)
      case 2: try decoder.decodeSingularBytesField(value: &self.parentBlockID)
      case 3: try decoder.decodeSingularBytesField(value: &self.blockID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 1)
    }
    if !self.parentBlockID.isEmpty {
      try visitor.visitSingularBytesField(value: self.parentBlockID, fieldNumber: 2)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularBytesField(value: self.blockID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Execution_ExecuteBlockRequest) -> Bool {
    if self.transactions != other.transactions {return false}
    if self.parentBlockID != other.parentBlockID {return false}
    if self.blockID != other.blockID {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Execution_ExecuteBlockResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecuteBlockResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_hash"),
    2: .same(proto: "status"),
    3: .same(proto: "version"),
    4: .same(proto: "validators"),
  ]

  fileprivate class _StorageClass {
    var _rootHash: Data = SwiftProtobuf.Internal.emptyData
    var _status: [Types_VMStatus] = []
    var _version: UInt64 = 0
    var _validators: Types_ValidatorSet? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _rootHash = source._rootHash
      _status = source._status
      _version = source._version
      _validators = source._validators
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._rootHash)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._status)
        case 3: try decoder.decodeSingularUInt64Field(value: &_storage._version)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._validators)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._rootHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._rootHash, fieldNumber: 1)
      }
      if !_storage._status.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._status, fieldNumber: 2)
      }
      if _storage._version != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._version, fieldNumber: 3)
      }
      if let v = _storage._validators {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Execution_ExecuteBlockResponse) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._rootHash != other_storage._rootHash {return false}
        if _storage._status != other_storage._status {return false}
        if _storage._version != other_storage._version {return false}
        if _storage._validators != other_storage._validators {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Execution_CommitBlockRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommitBlockRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ledger_info_with_sigs"),
  ]

  fileprivate class _StorageClass {
    var _ledgerInfoWithSigs: Types_LedgerInfoWithSignatures? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ledgerInfoWithSigs = source._ledgerInfoWithSigs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._ledgerInfoWithSigs)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._ledgerInfoWithSigs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Execution_CommitBlockRequest) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._ledgerInfoWithSigs != other_storage._ledgerInfoWithSigs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Execution_CommitBlockResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommitBlockResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .succeeded {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Execution_CommitBlockResponse) -> Bool {
    if self.status != other.status {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Execution_ExecuteChunkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecuteChunkRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "txn_list_with_proof"),
    2: .standard(proto: "ledger_info_with_sigs"),
  ]

  fileprivate class _StorageClass {
    var _txnListWithProof: Types_TransactionListWithProof? = nil
    var _ledgerInfoWithSigs: Types_LedgerInfoWithSignatures? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _txnListWithProof = source._txnListWithProof
      _ledgerInfoWithSigs = source._ledgerInfoWithSigs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._txnListWithProof)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._ledgerInfoWithSigs)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._txnListWithProof {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._ledgerInfoWithSigs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Execution_ExecuteChunkRequest) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._txnListWithProof != other_storage._txnListWithProof {return false}
        if _storage._ledgerInfoWithSigs != other_storage._ledgerInfoWithSigs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Execution_ExecuteChunkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecuteChunkResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Execution_ExecuteChunkResponse) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
