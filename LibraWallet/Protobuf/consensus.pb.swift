// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: consensus.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) The Libra Core Contributors
// SPDX-License-Identifier: Apache-2.0

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Network_BlockRetrievalStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Successfully fill in the request.
  case succeeded // = 0

  /// Can not find the block corresponding to block_id.
  case idNotFound // = 1

  /// Can not find enough blocks but find some.
  case notEnoughBlocks // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .succeeded
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .succeeded
    case 1: self = .idNotFound
    case 2: self = .notEnoughBlocks
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .succeeded: return 0
    case .idNotFound: return 1
    case .notEnoughBlocks: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

struct Network_ConsensusMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: OneOf_Message? {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  var proposal: Network_Proposal {
    get {
      if case .proposal(let v)? = _storage._message {return v}
      return Network_Proposal()
    }
    set {_uniqueStorage()._message = .proposal(newValue)}
  }

  var vote: Network_Vote {
    get {
      if case .vote(let v)? = _storage._message {return v}
      return Network_Vote()
    }
    set {_uniqueStorage()._message = .vote(newValue)}
  }

  var requestBlock: Network_RequestBlock {
    get {
      if case .requestBlock(let v)? = _storage._message {return v}
      return Network_RequestBlock()
    }
    set {_uniqueStorage()._message = .requestBlock(newValue)}
  }

  var respondBlock: Network_RespondBlock {
    get {
      if case .respondBlock(let v)? = _storage._message {return v}
      return Network_RespondBlock()
    }
    set {_uniqueStorage()._message = .respondBlock(newValue)}
  }

  var timeoutMsg: Network_TimeoutMsg {
    get {
      if case .timeoutMsg(let v)? = _storage._message {return v}
      return Network_TimeoutMsg()
    }
    set {_uniqueStorage()._message = .timeoutMsg(newValue)}
  }

  var syncInfo: Network_SyncInfo {
    get {
      if case .syncInfo(let v)? = _storage._message {return v}
      return Network_SyncInfo()
    }
    set {_uniqueStorage()._message = .syncInfo(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Message: Equatable {
    case proposal(Network_Proposal)
    case vote(Network_Vote)
    case requestBlock(Network_RequestBlock)
    case respondBlock(Network_RespondBlock)
    case timeoutMsg(Network_TimeoutMsg)
    case syncInfo(Network_SyncInfo)

    static func ==(lhs: Network_ConsensusMsg.OneOf_Message, rhs: Network_ConsensusMsg.OneOf_Message) -> Bool {
      switch (lhs, rhs) {
      case (.proposal(let l), .proposal(let r)): return l == r
      case (.vote(let l), .vote(let r)): return l == r
      case (.requestBlock(let l), .requestBlock(let r)): return l == r
      case (.respondBlock(let l), .respondBlock(let r)): return l == r
      case (.timeoutMsg(let l), .timeoutMsg(let r)): return l == r
      case (.syncInfo(let l), .syncInfo(let r)): return l == r
      default: return false
      }
    }
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Network_Proposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The proposed block
  var proposedBlock: Network_Block {
    get {return _storage._proposedBlock ?? Network_Block()}
    set {_uniqueStorage()._proposedBlock = newValue}
  }
  /// Returns true if `proposedBlock` has been explicitly set.
  var hasProposedBlock: Bool {return _storage._proposedBlock != nil}
  /// Clears the value of `proposedBlock`. Subsequent reads from it will return its default value.
  mutating func clearProposedBlock() {_storage._proposedBlock = nil}

  /// Information about the highest QC, LedgerInfo, TimeoutCertificate, etc.
  var syncInfo: Network_SyncInfo {
    get {return _storage._syncInfo ?? Network_SyncInfo()}
    set {_uniqueStorage()._syncInfo = newValue}
  }
  /// Returns true if `syncInfo` has been explicitly set.
  var hasSyncInfo: Bool {return _storage._syncInfo != nil}
  /// Clears the value of `syncInfo`. Subsequent reads from it will return its default value.
  mutating func clearSyncInfo() {_storage._syncInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Network_PacemakerTimeout {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Round that has timed out (e.g. we propose to switch to round + 1)
  var round: UInt64 {
    get {return _storage._round}
    set {_uniqueStorage()._round = newValue}
  }

  /// Author of timeout
  var author: Data {
    get {return _storage._author}
    set {_uniqueStorage()._author = newValue}
  }

  /// Signature that this timeout was authored by owner
  var signature: Data {
    get {return _storage._signature}
    set {_uniqueStorage()._signature = newValue}
  }

  /// Optional vote for the given round
  var vote: Network_Vote {
    get {return _storage._vote ?? Network_Vote()}
    set {_uniqueStorage()._vote = newValue}
  }
  /// Returns true if `vote` has been explicitly set.
  var hasVote: Bool {return _storage._vote != nil}
  /// Clears the value of `vote`. Subsequent reads from it will return its default value.
  mutating func clearVote() {_storage._vote = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Network_TimeoutMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Information about the highest QC, LedgerInfo, TimeoutCertificate, etc.
  var syncInfo: Network_SyncInfo {
    get {return _storage._syncInfo ?? Network_SyncInfo()}
    set {_uniqueStorage()._syncInfo = newValue}
  }
  /// Returns true if `syncInfo` has been explicitly set.
  var hasSyncInfo: Bool {return _storage._syncInfo != nil}
  /// Clears the value of `syncInfo`. Subsequent reads from it will return its default value.
  mutating func clearSyncInfo() {_storage._syncInfo = nil}

  /// Timeout
  var pacemakerTimeout: Network_PacemakerTimeout {
    get {return _storage._pacemakerTimeout ?? Network_PacemakerTimeout()}
    set {_uniqueStorage()._pacemakerTimeout = newValue}
  }
  /// Returns true if `pacemakerTimeout` has been explicitly set.
  var hasPacemakerTimeout: Bool {return _storage._pacemakerTimeout != nil}
  /// Clears the value of `pacemakerTimeout`. Subsequent reads from it will return its default value.
  mutating func clearPacemakerTimeout() {_storage._pacemakerTimeout = nil}

  /// Signature that this timeout was authored by owner
  var signature: Data {
    get {return _storage._signature}
    set {_uniqueStorage()._signature = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Network_SyncInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Highest quorum certificate
  var highestQuorumCert: Network_QuorumCert {
    get {return _storage._highestQuorumCert ?? Network_QuorumCert()}
    set {_uniqueStorage()._highestQuorumCert = newValue}
  }
  /// Returns true if `highestQuorumCert` has been explicitly set.
  var hasHighestQuorumCert: Bool {return _storage._highestQuorumCert != nil}
  /// Clears the value of `highestQuorumCert`. Subsequent reads from it will return its default value.
  mutating func clearHighestQuorumCert() {_storage._highestQuorumCert = nil}

  /// Highest ledger info
  var highestLedgerInfo: Network_QuorumCert {
    get {return _storage._highestLedgerInfo ?? Network_QuorumCert()}
    set {_uniqueStorage()._highestLedgerInfo = newValue}
  }
  /// Returns true if `highestLedgerInfo` has been explicitly set.
  var hasHighestLedgerInfo: Bool {return _storage._highestLedgerInfo != nil}
  /// Clears the value of `highestLedgerInfo`. Subsequent reads from it will return its default value.
  mutating func clearHighestLedgerInfo() {_storage._highestLedgerInfo = nil}

  /// Optional highest timeout certificate if available
  var highestTimeoutCert: Network_PacemakerTimeoutCertificate {
    get {return _storage._highestTimeoutCert ?? Network_PacemakerTimeoutCertificate()}
    set {_uniqueStorage()._highestTimeoutCert = newValue}
  }
  /// Returns true if `highestTimeoutCert` has been explicitly set.
  var hasHighestTimeoutCert: Bool {return _storage._highestTimeoutCert != nil}
  /// Clears the value of `highestTimeoutCert`. Subsequent reads from it will return its default value.
  mutating func clearHighestTimeoutCert() {_storage._highestTimeoutCert = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Network_PacemakerTimeoutCertificate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Round for which this certificate was created
  var round: UInt64 = 0

  /// List of certified timeouts
  var timeouts: [Network_PacemakerTimeout] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Network_Block {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This block's id as a hash value
  var id: Data {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Parent block id of this block as a hash value (all zeros to indicate the
  /// genesis block)
  var parentID: Data {
    get {return _storage._parentID}
    set {_uniqueStorage()._parentID = newValue}
  }

  /// Payload of the block (e.g. one or more transaction(s)
  var payload: Data {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  /// The round of the block (internal monotonically increasing counter).
  var round: UInt64 {
    get {return _storage._round}
    set {_uniqueStorage()._round = newValue}
  }

  /// The height of the block (position in the chain).
  var height: UInt64 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  /// The approximate physical microseconds since the epoch when the block was proposed
  var timestampUsecs: UInt64 {
    get {return _storage._timestampUsecs}
    set {_uniqueStorage()._timestampUsecs = newValue}
  }

  /// Contains the quorum certified ancestor and whether the quorum certified
  /// ancestor was voted on successfully
  var quorumCert: Network_QuorumCert {
    get {return _storage._quorumCert ?? Network_QuorumCert()}
    set {_uniqueStorage()._quorumCert = newValue}
  }
  /// Returns true if `quorumCert` has been explicitly set.
  var hasQuorumCert: Bool {return _storage._quorumCert != nil}
  /// Clears the value of `quorumCert`. Subsequent reads from it will return its default value.
  mutating func clearQuorumCert() {_storage._quorumCert = nil}

  /// Author of the block that can be validated by the author's public key and
  /// the signature
  var author: Data {
    get {return _storage._author}
    set {_uniqueStorage()._author = newValue}
  }

  /// Signature that the hash of this block has been authored by the owner of the
  /// private key
  var signature: Data {
    get {return _storage._signature}
    set {_uniqueStorage()._signature = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Network_QuorumCert {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The vote information certified by the quorum.
  var voteData: Network_VoteData {
    get {return _storage._voteData ?? Network_VoteData()}
    set {_uniqueStorage()._voteData = newValue}
  }
  /// Returns true if `voteData` has been explicitly set.
  var hasVoteData: Bool {return _storage._voteData != nil}
  /// Clears the value of `voteData`. Subsequent reads from it will return its default value.
  mutating func clearVoteData() {_storage._voteData = nil}

  /// LedgerInfo with at least 2f+1 signatures. The LedgerInfo's consensus data
  /// hash is a digest that covers vote data hash.
  var signedLedgerInfo: Types_LedgerInfoWithSignatures {
    get {return _storage._signedLedgerInfo ?? Types_LedgerInfoWithSignatures()}
    set {_uniqueStorage()._signedLedgerInfo = newValue}
  }
  /// Returns true if `signedLedgerInfo` has been explicitly set.
  var hasSignedLedgerInfo: Bool {return _storage._signedLedgerInfo != nil}
  /// Clears the value of `signedLedgerInfo`. Subsequent reads from it will return its default value.
  mutating func clearSignedLedgerInfo() {_storage._signedLedgerInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Network_VoteData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the block being vote for.
  var blockID: Data = SwiftProtobuf.Internal.emptyData

  /// The id and the version of the state after executing the block.
  var executedStateID: Data = SwiftProtobuf.Internal.emptyData

  /// The round of the block being voted for
  var round: UInt64 = 0

  /// The id of the parent block
  var parentBlockID: Data = SwiftProtobuf.Internal.emptyData

  /// The round of the parent block
  var parentBlockRound: UInt64 = 0

  /// The id of the grandparent block
  var grandparentBlockID: Data = SwiftProtobuf.Internal.emptyData

  /// The round of the grandparent block
  var grandparentBlockRound: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Network_Vote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The actual vote information.
  var voteData: Network_VoteData {
    get {return _storage._voteData ?? Network_VoteData()}
    set {_uniqueStorage()._voteData = newValue}
  }
  /// Returns true if `voteData` has been explicitly set.
  var hasVoteData: Bool {return _storage._voteData != nil}
  /// Clears the value of `voteData`. Subsequent reads from it will return its default value.
  mutating func clearVoteData() {_storage._voteData = nil}

  /// Author of the vote.
  var author: Data {
    get {return _storage._author}
    set {_uniqueStorage()._author = newValue}
  }

  /// The ledger info carried with the vote (corresponding to the block of a
  /// potentially committed txn).
  var ledgerInfo: Types_LedgerInfo {
    get {return _storage._ledgerInfo ?? Types_LedgerInfo()}
    set {_uniqueStorage()._ledgerInfo = newValue}
  }
  /// Returns true if `ledgerInfo` has been explicitly set.
  var hasLedgerInfo: Bool {return _storage._ledgerInfo != nil}
  /// Clears the value of `ledgerInfo`. Subsequent reads from it will return its default value.
  mutating func clearLedgerInfo() {_storage._ledgerInfo = nil}

  /// Signature of the ledger info.
  var signature: Data {
    get {return _storage._signature}
    set {_uniqueStorage()._signature = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Network_RequestBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the requested block.
  var blockID: Data = SwiftProtobuf.Internal.emptyData

  var numBlocks: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Network_RespondBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Network_BlockRetrievalStatus = .succeeded

  /// The responded block.
  var blocks: [Network_Block] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "network"

extension Network_BlockRetrievalStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUCCEEDED"),
    1: .same(proto: "ID_NOT_FOUND"),
    2: .same(proto: "NOT_ENOUGH_BLOCKS"),
  ]
}

extension Network_ConsensusMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConsensusMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proposal"),
    2: .same(proto: "vote"),
    3: .standard(proto: "request_block"),
    4: .standard(proto: "respond_block"),
    5: .standard(proto: "timeout_msg"),
    6: .standard(proto: "sync_info"),
  ]

  fileprivate class _StorageClass {
    var _message: Network_ConsensusMsg.OneOf_Message?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Network_Proposal?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .proposal(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .proposal(v)}
        case 2:
          var v: Network_Vote?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .vote(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .vote(v)}
        case 3:
          var v: Network_RequestBlock?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .requestBlock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .requestBlock(v)}
        case 4:
          var v: Network_RespondBlock?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .respondBlock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .respondBlock(v)}
        case 5:
          var v: Network_TimeoutMsg?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .timeoutMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .timeoutMsg(v)}
        case 6:
          var v: Network_SyncInfo?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .syncInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .syncInfo(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._message {
      case .proposal(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .vote(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .requestBlock(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .respondBlock(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .timeoutMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .syncInfo(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Network_ConsensusMsg) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._message != other_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Network_Proposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Proposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "proposed_block"),
    2: .standard(proto: "sync_info"),
  ]

  fileprivate class _StorageClass {
    var _proposedBlock: Network_Block? = nil
    var _syncInfo: Network_SyncInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _proposedBlock = source._proposedBlock
      _syncInfo = source._syncInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._proposedBlock)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._syncInfo)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._proposedBlock {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._syncInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Network_Proposal) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._proposedBlock != other_storage._proposedBlock {return false}
        if _storage._syncInfo != other_storage._syncInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Network_PacemakerTimeout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PacemakerTimeout"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "round"),
    2: .same(proto: "author"),
    3: .same(proto: "signature"),
    4: .same(proto: "vote"),
  ]

  fileprivate class _StorageClass {
    var _round: UInt64 = 0
    var _author: Data = SwiftProtobuf.Internal.emptyData
    var _signature: Data = SwiftProtobuf.Internal.emptyData
    var _vote: Network_Vote? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _round = source._round
      _author = source._author
      _signature = source._signature
      _vote = source._vote
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._round)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._author)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._signature)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._vote)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._round != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._round, fieldNumber: 1)
      }
      if !_storage._author.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._author, fieldNumber: 2)
      }
      if !_storage._signature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signature, fieldNumber: 3)
      }
      if let v = _storage._vote {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Network_PacemakerTimeout) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._round != other_storage._round {return false}
        if _storage._author != other_storage._author {return false}
        if _storage._signature != other_storage._signature {return false}
        if _storage._vote != other_storage._vote {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Network_TimeoutMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimeoutMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sync_info"),
    2: .standard(proto: "pacemaker_timeout"),
    3: .same(proto: "signature"),
  ]

  fileprivate class _StorageClass {
    var _syncInfo: Network_SyncInfo? = nil
    var _pacemakerTimeout: Network_PacemakerTimeout? = nil
    var _signature: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _syncInfo = source._syncInfo
      _pacemakerTimeout = source._pacemakerTimeout
      _signature = source._signature
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._syncInfo)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._pacemakerTimeout)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._signature)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._syncInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._pacemakerTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._signature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signature, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Network_TimeoutMsg) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._syncInfo != other_storage._syncInfo {return false}
        if _storage._pacemakerTimeout != other_storage._pacemakerTimeout {return false}
        if _storage._signature != other_storage._signature {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Network_SyncInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "highest_quorum_cert"),
    2: .standard(proto: "highest_ledger_info"),
    3: .standard(proto: "highest_timeout_cert"),
  ]

  fileprivate class _StorageClass {
    var _highestQuorumCert: Network_QuorumCert? = nil
    var _highestLedgerInfo: Network_QuorumCert? = nil
    var _highestTimeoutCert: Network_PacemakerTimeoutCertificate? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _highestQuorumCert = source._highestQuorumCert
      _highestLedgerInfo = source._highestLedgerInfo
      _highestTimeoutCert = source._highestTimeoutCert
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._highestQuorumCert)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._highestLedgerInfo)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._highestTimeoutCert)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._highestQuorumCert {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._highestLedgerInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._highestTimeoutCert {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Network_SyncInfo) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._highestQuorumCert != other_storage._highestQuorumCert {return false}
        if _storage._highestLedgerInfo != other_storage._highestLedgerInfo {return false}
        if _storage._highestTimeoutCert != other_storage._highestTimeoutCert {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Network_PacemakerTimeoutCertificate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PacemakerTimeoutCertificate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "round"),
    2: .same(proto: "timeouts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.round)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.timeouts)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.round != 0 {
      try visitor.visitSingularUInt64Field(value: self.round, fieldNumber: 1)
    }
    if !self.timeouts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.timeouts, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Network_PacemakerTimeoutCertificate) -> Bool {
    if self.round != other.round {return false}
    if self.timeouts != other.timeouts {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Network_Block: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Block"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "parent_id"),
    3: .same(proto: "payload"),
    4: .same(proto: "round"),
    5: .same(proto: "height"),
    6: .standard(proto: "timestamp_usecs"),
    7: .standard(proto: "quorum_cert"),
    8: .same(proto: "author"),
    9: .same(proto: "signature"),
  ]

  fileprivate class _StorageClass {
    var _id: Data = SwiftProtobuf.Internal.emptyData
    var _parentID: Data = SwiftProtobuf.Internal.emptyData
    var _payload: Data = SwiftProtobuf.Internal.emptyData
    var _round: UInt64 = 0
    var _height: UInt64 = 0
    var _timestampUsecs: UInt64 = 0
    var _quorumCert: Network_QuorumCert? = nil
    var _author: Data = SwiftProtobuf.Internal.emptyData
    var _signature: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _parentID = source._parentID
      _payload = source._payload
      _round = source._round
      _height = source._height
      _timestampUsecs = source._timestampUsecs
      _quorumCert = source._quorumCert
      _author = source._author
      _signature = source._signature
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._id)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._parentID)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._payload)
        case 4: try decoder.decodeSingularUInt64Field(value: &_storage._round)
        case 5: try decoder.decodeSingularUInt64Field(value: &_storage._height)
        case 6: try decoder.decodeSingularUInt64Field(value: &_storage._timestampUsecs)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._quorumCert)
        case 8: try decoder.decodeSingularBytesField(value: &_storage._author)
        case 9: try decoder.decodeSingularBytesField(value: &_storage._signature)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._parentID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._parentID, fieldNumber: 2)
      }
      if !_storage._payload.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._payload, fieldNumber: 3)
      }
      if _storage._round != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._round, fieldNumber: 4)
      }
      if _storage._height != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._height, fieldNumber: 5)
      }
      if _storage._timestampUsecs != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._timestampUsecs, fieldNumber: 6)
      }
      if let v = _storage._quorumCert {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._author.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._author, fieldNumber: 8)
      }
      if !_storage._signature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signature, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Network_Block) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._id != other_storage._id {return false}
        if _storage._parentID != other_storage._parentID {return false}
        if _storage._payload != other_storage._payload {return false}
        if _storage._round != other_storage._round {return false}
        if _storage._height != other_storage._height {return false}
        if _storage._timestampUsecs != other_storage._timestampUsecs {return false}
        if _storage._quorumCert != other_storage._quorumCert {return false}
        if _storage._author != other_storage._author {return false}
        if _storage._signature != other_storage._signature {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Network_QuorumCert: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuorumCert"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vote_data"),
    2: .standard(proto: "signed_ledger_info"),
  ]

  fileprivate class _StorageClass {
    var _voteData: Network_VoteData? = nil
    var _signedLedgerInfo: Types_LedgerInfoWithSignatures? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _voteData = source._voteData
      _signedLedgerInfo = source._signedLedgerInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._voteData)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._signedLedgerInfo)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._voteData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._signedLedgerInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Network_QuorumCert) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._voteData != other_storage._voteData {return false}
        if _storage._signedLedgerInfo != other_storage._signedLedgerInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Network_VoteData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VoteData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_id"),
    2: .standard(proto: "executed_state_id"),
    3: .same(proto: "round"),
    4: .standard(proto: "parent_block_id"),
    5: .standard(proto: "parent_block_round"),
    6: .standard(proto: "grandparent_block_id"),
    7: .standard(proto: "grandparent_block_round"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.blockID)
      case 2: try decoder.decodeSingularBytesField(value: &self.executedStateID)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.round)
      case 4: try decoder.decodeSingularBytesField(value: &self.parentBlockID)
      case 5: try decoder.decodeSingularUInt64Field(value: &self.parentBlockRound)
      case 6: try decoder.decodeSingularBytesField(value: &self.grandparentBlockID)
      case 7: try decoder.decodeSingularUInt64Field(value: &self.grandparentBlockRound)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blockID.isEmpty {
      try visitor.visitSingularBytesField(value: self.blockID, fieldNumber: 1)
    }
    if !self.executedStateID.isEmpty {
      try visitor.visitSingularBytesField(value: self.executedStateID, fieldNumber: 2)
    }
    if self.round != 0 {
      try visitor.visitSingularUInt64Field(value: self.round, fieldNumber: 3)
    }
    if !self.parentBlockID.isEmpty {
      try visitor.visitSingularBytesField(value: self.parentBlockID, fieldNumber: 4)
    }
    if self.parentBlockRound != 0 {
      try visitor.visitSingularUInt64Field(value: self.parentBlockRound, fieldNumber: 5)
    }
    if !self.grandparentBlockID.isEmpty {
      try visitor.visitSingularBytesField(value: self.grandparentBlockID, fieldNumber: 6)
    }
    if self.grandparentBlockRound != 0 {
      try visitor.visitSingularUInt64Field(value: self.grandparentBlockRound, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Network_VoteData) -> Bool {
    if self.blockID != other.blockID {return false}
    if self.executedStateID != other.executedStateID {return false}
    if self.round != other.round {return false}
    if self.parentBlockID != other.parentBlockID {return false}
    if self.parentBlockRound != other.parentBlockRound {return false}
    if self.grandparentBlockID != other.grandparentBlockID {return false}
    if self.grandparentBlockRound != other.grandparentBlockRound {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Network_Vote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Vote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vote_data"),
    2: .same(proto: "author"),
    3: .standard(proto: "ledger_info"),
    4: .same(proto: "signature"),
  ]

  fileprivate class _StorageClass {
    var _voteData: Network_VoteData? = nil
    var _author: Data = SwiftProtobuf.Internal.emptyData
    var _ledgerInfo: Types_LedgerInfo? = nil
    var _signature: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _voteData = source._voteData
      _author = source._author
      _ledgerInfo = source._ledgerInfo
      _signature = source._signature
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._voteData)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._author)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._ledgerInfo)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._signature)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._voteData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._author.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._author, fieldNumber: 2)
      }
      if let v = _storage._ledgerInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._signature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signature, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Network_Vote) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._voteData != other_storage._voteData {return false}
        if _storage._author != other_storage._author {return false}
        if _storage._ledgerInfo != other_storage._ledgerInfo {return false}
        if _storage._signature != other_storage._signature {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Network_RequestBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestBlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_id"),
    2: .standard(proto: "num_blocks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.blockID)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.numBlocks)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blockID.isEmpty {
      try visitor.visitSingularBytesField(value: self.blockID, fieldNumber: 1)
    }
    if self.numBlocks != 0 {
      try visitor.visitSingularUInt64Field(value: self.numBlocks, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Network_RequestBlock) -> Bool {
    if self.blockID != other.blockID {return false}
    if self.numBlocks != other.numBlocks {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Network_RespondBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RespondBlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "blocks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.status)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.blocks)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .succeeded {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Network_RespondBlock) -> Bool {
    if self.status != other.status {return false}
    if self.blocks != other.blocks {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
