// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: transaction.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) The Libra Core Contributors
// SPDX-License-Identifier: Apache-2.0

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Type of write operation
enum Types_WriteOpType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// The WriteOp is to create/update the field from storage.
  case write // = 0

  /// The WriteOp is to delete the field from storage.
  case delete // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .write
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .write
    case 1: self = .delete
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .write: return 0
    case .delete: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Types_WriteOpType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Types_WriteOpType] = [
    .write,
    .delete,
  ]
}

#endif  // swift(>=4.2)

/// A generic structure that describes a transaction that a client submits
struct Types_RawTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sender's account address
  var senderAccount: Data {
    get {return _storage._senderAccount}
    set {_uniqueStorage()._senderAccount = newValue}
  }

  /// Sequence number of this transaction corresponding to sender's account.
  var sequenceNumber: UInt64 {
    get {return _storage._sequenceNumber}
    set {_uniqueStorage()._sequenceNumber = newValue}
  }

  var payload: OneOf_Payload? {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  /// The transaction script to execute.
  var program: Types_Program {
    get {
      if case .program(let v)? = _storage._payload {return v}
      return Types_Program()
    }
    set {_uniqueStorage()._payload = .program(newValue)}
  }

  /// A write set, used for genesis blocks and other magic transactions.
  /// This bypasses the rules for regular transactions so will typically be
  /// rejected. Only under special circumstances will it be accepted.
  var writeSet: Types_WriteSet {
    get {
      if case .writeSet(let v)? = _storage._payload {return v}
      return Types_WriteSet()
    }
    set {_uniqueStorage()._payload = .writeSet(newValue)}
  }

  /// Maximal total gas specified by wallet to spend for this transaction.
  var maxGasAmount: UInt64 {
    get {return _storage._maxGasAmount}
    set {_uniqueStorage()._maxGasAmount = newValue}
  }

  /// The price to be paid for each unit of gas.
  var gasUnitPrice: UInt64 {
    get {return _storage._gasUnitPrice}
    set {_uniqueStorage()._gasUnitPrice = newValue}
  }

  /// Expiration time for this transaction.  If storage is queried and
  /// the time returned is greater than or equal to this time and this
  /// transaction has not been included, you can be certain that it will
  /// never be included.
  /// If set to 0, there will be no expiration time
  var expirationTime: UInt64 {
    get {return _storage._expirationTime}
    set {_uniqueStorage()._expirationTime = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Payload: Equatable {
    /// The transaction script to execute.
    case program(Types_Program)
    /// A write set, used for genesis blocks and other magic transactions.
    /// This bypasses the rules for regular transactions so will typically be
    /// rejected. Only under special circumstances will it be accepted.
    case writeSet(Types_WriteSet)

  #if !swift(>=4.1)
    static func ==(lhs: Types_RawTransaction.OneOf_Payload, rhs: Types_RawTransaction.OneOf_Payload) -> Bool {
      switch (lhs, rhs) {
      case (.program(let l), .program(let r)): return l == r
      case (.writeSet(let l), .writeSet(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The code for the transaction to execute
struct Types_Program {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: Data = SwiftProtobuf.Internal.emptyData

  var arguments: [Types_TransactionArgument] = []

  var modules: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An argument to the transaction if the transaction takes arguments
struct Types_TransactionArgument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Types_TransactionArgument.ArgType = .u64

  var data: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ArgType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case u64 // = 0
    case address // = 1
    case string // = 2
    case bytearray // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .u64
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .u64
      case 1: self = .address
      case 2: self = .string
      case 3: self = .bytearray
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .u64: return 0
      case .address: return 1
      case .string: return 2
      case .bytearray: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Types_TransactionArgument.ArgType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Types_TransactionArgument.ArgType] = [
    .u64,
    .address,
    .string,
    .bytearray,
  ]
}

#endif  // swift(>=4.2)

/// A generic structure that represents signed RawTransaction
struct Types_SignedTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The serialized Protobuf bytes for RawTransaction, for which the signature
  /// was signed. Protobuf doesn't guarantee the serialized bytes is canonical
  /// across different language implementations, but for our use cases for
  /// transaction it is not necessary because the client is the only one to
  /// produce this bytes, which is then persisted in storage.
  var rawTxnBytes: Data = SwiftProtobuf.Internal.emptyData

  /// public key that corresponds to RawTransaction::sender_account
  var senderPublicKey: Data = SwiftProtobuf.Internal.emptyData

  /// signature for the hash
  var senderSignature: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_SignedTransactionWithProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The version of the returned signed transaction.
  var version: UInt64 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// The transaction itself.
  var signedTransaction: Types_SignedTransaction {
    get {return _storage._signedTransaction ?? Types_SignedTransaction()}
    set {_uniqueStorage()._signedTransaction = newValue}
  }
  /// Returns true if `signedTransaction` has been explicitly set.
  var hasSignedTransaction: Bool {return _storage._signedTransaction != nil}
  /// Clears the value of `signedTransaction`. Subsequent reads from it will return its default value.
  mutating func clearSignedTransaction() {_uniqueStorage()._signedTransaction = nil}

  /// The proof authenticating the signed transaction.
  var proof: Types_SignedTransactionProof {
    get {return _storage._proof ?? Types_SignedTransactionProof()}
    set {_uniqueStorage()._proof = newValue}
  }
  /// Returns true if `proof` has been explicitly set.
  var hasProof: Bool {return _storage._proof != nil}
  /// Clears the value of `proof`. Subsequent reads from it will return its default value.
  mutating func clearProof() {_uniqueStorage()._proof = nil}

  /// The events yielded by executing the transaction, if requested.
  var events: Types_EventsList {
    get {return _storage._events ?? Types_EventsList()}
    set {_uniqueStorage()._events = newValue}
  }
  /// Returns true if `events` has been explicitly set.
  var hasEvents: Bool {return _storage._events != nil}
  /// Clears the value of `events`. Subsequent reads from it will return its default value.
  mutating func clearEvents() {_uniqueStorage()._events = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A generic structure that represents a block of transactions originated from a
/// particular validator instance.
struct Types_SignedTransactionsBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Set of Signed Transactions
  var transactions: [Types_SignedTransaction] = []

  /// Public key of the validator that created this block
  var validatorPublicKey: Data = SwiftProtobuf.Internal.emptyData

  /// Signature of the validator that created this block
  var validatorSignature: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Set of WriteOps to save to storage.
struct Types_WriteSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Set of WriteOp for storage update.
  var writeSet: [Types_WriteOp] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Write Operation on underlying storage.
struct Types_WriteOp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// AccessPath of the write set.
  var accessPath: Types_AccessPath {
    get {return _storage._accessPath ?? Types_AccessPath()}
    set {_uniqueStorage()._accessPath = newValue}
  }
  /// Returns true if `accessPath` has been explicitly set.
  var hasAccessPath: Bool {return _storage._accessPath != nil}
  /// Clears the value of `accessPath`. Subsequent reads from it will return its default value.
  mutating func clearAccessPath() {_uniqueStorage()._accessPath = nil}

  /// The value of the write op. Empty if `type` is Delete.
  var value: Data {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  /// WriteOp type.
  var type: Types_WriteOpType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Account state as a whole.
/// After execution, updates to accounts are passed in this form to storage for
/// persistence.
struct Types_AccountState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Account address
  var address: Data = SwiftProtobuf.Internal.emptyData

  /// Account state blob
  var blob: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Transaction struct to commit to storage
struct Types_TransactionToCommit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The signed transaction which was executed
  var signedTxn: Types_SignedTransaction {
    get {return _storage._signedTxn ?? Types_SignedTransaction()}
    set {_uniqueStorage()._signedTxn = newValue}
  }
  /// Returns true if `signedTxn` has been explicitly set.
  var hasSignedTxn: Bool {return _storage._signedTxn != nil}
  /// Clears the value of `signedTxn`. Subsequent reads from it will return its default value.
  mutating func clearSignedTxn() {_uniqueStorage()._signedTxn = nil}

  /// State db updates
  var accountStates: [Types_AccountState] {
    get {return _storage._accountStates}
    set {_uniqueStorage()._accountStates = newValue}
  }

  /// Events yielded by the transaction.
  var events: [Types_Event] {
    get {return _storage._events}
    set {_uniqueStorage()._events = newValue}
  }

  /// The amount of gas used.
  var gasUsed: UInt64 {
    get {return _storage._gasUsed}
    set {_uniqueStorage()._gasUsed = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A list of consecutive transactions with proof. This is mainly used for state
/// synchronization when a validator would request a list of transactions from a
/// peer, verify the proof, execute the transactions and persist them. Note that
/// the transactions are supposed to belong to the same epoch E, otherwise
/// verification will fail.
struct Types_TransactionListWithProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of transactions.
  var transactions: [Types_SignedTransaction] {
    get {return _storage._transactions}
    set {_uniqueStorage()._transactions = newValue}
  }

  /// The list of corresponding TransactionInfo objects.
  var infos: [Types_TransactionInfo] {
    get {return _storage._infos}
    set {_uniqueStorage()._infos = newValue}
  }

  /// The list of corresponding Event objects (only present if fetch_events was set to true in req)
  var eventsForVersions: Types_EventsForVersions {
    get {return _storage._eventsForVersions ?? Types_EventsForVersions()}
    set {_uniqueStorage()._eventsForVersions = newValue}
  }
  /// Returns true if `eventsForVersions` has been explicitly set.
  var hasEventsForVersions: Bool {return _storage._eventsForVersions != nil}
  /// Clears the value of `eventsForVersions`. Subsequent reads from it will return its default value.
  mutating func clearEventsForVersions() {_uniqueStorage()._eventsForVersions = nil}

  /// If the list is not empty, the version of the first transaction.
  var firstTransactionVersion: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _storage._firstTransactionVersion ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_uniqueStorage()._firstTransactionVersion = newValue}
  }
  /// Returns true if `firstTransactionVersion` has been explicitly set.
  var hasFirstTransactionVersion: Bool {return _storage._firstTransactionVersion != nil}
  /// Clears the value of `firstTransactionVersion`. Subsequent reads from it will return its default value.
  mutating func clearFirstTransactionVersion() {_uniqueStorage()._firstTransactionVersion = nil}

  /// The proofs of the first and last transaction in this chunk. When this is
  /// used for state synchronization, the validator who requests the transactions
  /// will provide a version in the request and the proofs will be relative to
  /// the given version. When this is returned in GetTransactionsResponse, the
  /// proofs will be relative to the ledger info returned in
  /// UpdateToLatestLedgerResponse.
  var proofOfFirstTransaction: Types_AccumulatorProof {
    get {return _storage._proofOfFirstTransaction ?? Types_AccumulatorProof()}
    set {_uniqueStorage()._proofOfFirstTransaction = newValue}
  }
  /// Returns true if `proofOfFirstTransaction` has been explicitly set.
  var hasProofOfFirstTransaction: Bool {return _storage._proofOfFirstTransaction != nil}
  /// Clears the value of `proofOfFirstTransaction`. Subsequent reads from it will return its default value.
  mutating func clearProofOfFirstTransaction() {_uniqueStorage()._proofOfFirstTransaction = nil}

  var proofOfLastTransaction: Types_AccumulatorProof {
    get {return _storage._proofOfLastTransaction ?? Types_AccumulatorProof()}
    set {_uniqueStorage()._proofOfLastTransaction = newValue}
  }
  /// Returns true if `proofOfLastTransaction` has been explicitly set.
  var hasProofOfLastTransaction: Bool {return _storage._proofOfLastTransaction != nil}
  /// Clears the value of `proofOfLastTransaction`. Subsequent reads from it will return its default value.
  mutating func clearProofOfLastTransaction() {_uniqueStorage()._proofOfLastTransaction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "types"

extension Types_WriteOpType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Write"),
    1: .same(proto: "Delete"),
  ]
}

extension Types_RawTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RawTransaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sender_account"),
    2: .standard(proto: "sequence_number"),
    3: .same(proto: "program"),
    4: .standard(proto: "write_set"),
    5: .standard(proto: "max_gas_amount"),
    6: .standard(proto: "gas_unit_price"),
    7: .standard(proto: "expiration_time"),
  ]

  fileprivate class _StorageClass {
    var _senderAccount: Data = SwiftProtobuf.Internal.emptyData
    var _sequenceNumber: UInt64 = 0
    var _payload: Types_RawTransaction.OneOf_Payload?
    var _maxGasAmount: UInt64 = 0
    var _gasUnitPrice: UInt64 = 0
    var _expirationTime: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _senderAccount = source._senderAccount
      _sequenceNumber = source._sequenceNumber
      _payload = source._payload
      _maxGasAmount = source._maxGasAmount
      _gasUnitPrice = source._gasUnitPrice
      _expirationTime = source._expirationTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._senderAccount)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._sequenceNumber)
        case 3:
          var v: Types_Program?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .program(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .program(v)}
        case 4:
          var v: Types_WriteSet?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .writeSet(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .writeSet(v)}
        case 5: try decoder.decodeSingularUInt64Field(value: &_storage._maxGasAmount)
        case 6: try decoder.decodeSingularUInt64Field(value: &_storage._gasUnitPrice)
        case 7: try decoder.decodeSingularUInt64Field(value: &_storage._expirationTime)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._senderAccount.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._senderAccount, fieldNumber: 1)
      }
      if _storage._sequenceNumber != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._sequenceNumber, fieldNumber: 2)
      }
      switch _storage._payload {
      case .program(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .writeSet(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case nil: break
      }
      if _storage._maxGasAmount != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._maxGasAmount, fieldNumber: 5)
      }
      if _storage._gasUnitPrice != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._gasUnitPrice, fieldNumber: 6)
      }
      if _storage._expirationTime != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._expirationTime, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_RawTransaction, rhs: Types_RawTransaction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._senderAccount != rhs_storage._senderAccount {return false}
        if _storage._sequenceNumber != rhs_storage._sequenceNumber {return false}
        if _storage._payload != rhs_storage._payload {return false}
        if _storage._maxGasAmount != rhs_storage._maxGasAmount {return false}
        if _storage._gasUnitPrice != rhs_storage._gasUnitPrice {return false}
        if _storage._expirationTime != rhs_storage._expirationTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_Program: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Program"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "arguments"),
    3: .same(proto: "modules"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.code)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.arguments)
      case 3: try decoder.decodeRepeatedBytesField(value: &self.modules)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularBytesField(value: self.code, fieldNumber: 1)
    }
    if !self.arguments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.arguments, fieldNumber: 2)
    }
    if !self.modules.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.modules, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_Program, rhs: Types_Program) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.arguments != rhs.arguments {return false}
    if lhs.modules != rhs.modules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_TransactionArgument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionArgument"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularBytesField(value: &self.data)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .u64 {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_TransactionArgument, rhs: Types_TransactionArgument) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_TransactionArgument.ArgType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "U64"),
    1: .same(proto: "ADDRESS"),
    2: .same(proto: "STRING"),
    3: .same(proto: "BYTEARRAY"),
  ]
}

extension Types_SignedTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignedTransaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_txn_bytes"),
    2: .standard(proto: "sender_public_key"),
    3: .standard(proto: "sender_signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.rawTxnBytes)
      case 2: try decoder.decodeSingularBytesField(value: &self.senderPublicKey)
      case 3: try decoder.decodeSingularBytesField(value: &self.senderSignature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rawTxnBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawTxnBytes, fieldNumber: 1)
    }
    if !self.senderPublicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.senderPublicKey, fieldNumber: 2)
    }
    if !self.senderSignature.isEmpty {
      try visitor.visitSingularBytesField(value: self.senderSignature, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SignedTransaction, rhs: Types_SignedTransaction) -> Bool {
    if lhs.rawTxnBytes != rhs.rawTxnBytes {return false}
    if lhs.senderPublicKey != rhs.senderPublicKey {return false}
    if lhs.senderSignature != rhs.senderSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SignedTransactionWithProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignedTransactionWithProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "signed_transaction"),
    3: .same(proto: "proof"),
    4: .same(proto: "events"),
  ]

  fileprivate class _StorageClass {
    var _version: UInt64 = 0
    var _signedTransaction: Types_SignedTransaction? = nil
    var _proof: Types_SignedTransactionProof? = nil
    var _events: Types_EventsList? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _version = source._version
      _signedTransaction = source._signedTransaction
      _proof = source._proof
      _events = source._events
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._version)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._signedTransaction)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._proof)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._events)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._version != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._version, fieldNumber: 1)
      }
      if let v = _storage._signedTransaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._proof {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._events {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SignedTransactionWithProof, rhs: Types_SignedTransactionWithProof) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._version != rhs_storage._version {return false}
        if _storage._signedTransaction != rhs_storage._signedTransaction {return false}
        if _storage._proof != rhs_storage._proof {return false}
        if _storage._events != rhs_storage._events {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SignedTransactionsBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignedTransactionsBlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactions"),
    2: .standard(proto: "validator_public_key"),
    3: .standard(proto: "validator_signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.transactions)
      case 2: try decoder.decodeSingularBytesField(value: &self.validatorPublicKey)
      case 3: try decoder.decodeSingularBytesField(value: &self.validatorSignature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 1)
    }
    if !self.validatorPublicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.validatorPublicKey, fieldNumber: 2)
    }
    if !self.validatorSignature.isEmpty {
      try visitor.visitSingularBytesField(value: self.validatorSignature, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SignedTransactionsBlock, rhs: Types_SignedTransactionsBlock) -> Bool {
    if lhs.transactions != rhs.transactions {return false}
    if lhs.validatorPublicKey != rhs.validatorPublicKey {return false}
    if lhs.validatorSignature != rhs.validatorSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_WriteSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteSet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "write_set"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.writeSet)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.writeSet.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.writeSet, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_WriteSet, rhs: Types_WriteSet) -> Bool {
    if lhs.writeSet != rhs.writeSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_WriteOp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteOp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_path"),
    2: .same(proto: "value"),
    3: .same(proto: "type"),
  ]

  fileprivate class _StorageClass {
    var _accessPath: Types_AccessPath? = nil
    var _value: Data = SwiftProtobuf.Internal.emptyData
    var _type: Types_WriteOpType = .write

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _accessPath = source._accessPath
      _value = source._value
      _type = source._type
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._accessPath)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._value)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._type)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._accessPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._value.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._value, fieldNumber: 2)
      }
      if _storage._type != .write {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_WriteOp, rhs: Types_WriteOp) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._accessPath != rhs_storage._accessPath {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._type != rhs_storage._type {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AccountState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "blob"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.address)
      case 2: try decoder.decodeSingularBytesField(value: &self.blob)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if !self.blob.isEmpty {
      try visitor.visitSingularBytesField(value: self.blob, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AccountState, rhs: Types_AccountState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.blob != rhs.blob {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_TransactionToCommit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionToCommit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signed_txn"),
    2: .standard(proto: "account_states"),
    3: .same(proto: "events"),
    4: .standard(proto: "gas_used"),
  ]

  fileprivate class _StorageClass {
    var _signedTxn: Types_SignedTransaction? = nil
    var _accountStates: [Types_AccountState] = []
    var _events: [Types_Event] = []
    var _gasUsed: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _signedTxn = source._signedTxn
      _accountStates = source._accountStates
      _events = source._events
      _gasUsed = source._gasUsed
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._signedTxn)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._accountStates)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._events)
        case 4: try decoder.decodeSingularUInt64Field(value: &_storage._gasUsed)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._signedTxn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._accountStates.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._accountStates, fieldNumber: 2)
      }
      if !_storage._events.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._events, fieldNumber: 3)
      }
      if _storage._gasUsed != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._gasUsed, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_TransactionToCommit, rhs: Types_TransactionToCommit) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._signedTxn != rhs_storage._signedTxn {return false}
        if _storage._accountStates != rhs_storage._accountStates {return false}
        if _storage._events != rhs_storage._events {return false}
        if _storage._gasUsed != rhs_storage._gasUsed {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_TransactionListWithProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionListWithProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactions"),
    2: .same(proto: "infos"),
    3: .standard(proto: "events_for_versions"),
    4: .standard(proto: "first_transaction_version"),
    5: .standard(proto: "proof_of_first_transaction"),
    6: .standard(proto: "proof_of_last_transaction"),
  ]

  fileprivate class _StorageClass {
    var _transactions: [Types_SignedTransaction] = []
    var _infos: [Types_TransactionInfo] = []
    var _eventsForVersions: Types_EventsForVersions? = nil
    var _firstTransactionVersion: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    var _proofOfFirstTransaction: Types_AccumulatorProof? = nil
    var _proofOfLastTransaction: Types_AccumulatorProof? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transactions = source._transactions
      _infos = source._infos
      _eventsForVersions = source._eventsForVersions
      _firstTransactionVersion = source._firstTransactionVersion
      _proofOfFirstTransaction = source._proofOfFirstTransaction
      _proofOfLastTransaction = source._proofOfLastTransaction
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._transactions)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._infos)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._eventsForVersions)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._firstTransactionVersion)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._proofOfFirstTransaction)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._proofOfLastTransaction)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._transactions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._transactions, fieldNumber: 1)
      }
      if !_storage._infos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._infos, fieldNumber: 2)
      }
      if let v = _storage._eventsForVersions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._firstTransactionVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._proofOfFirstTransaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._proofOfLastTransaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_TransactionListWithProof, rhs: Types_TransactionListWithProof) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transactions != rhs_storage._transactions {return false}
        if _storage._infos != rhs_storage._infos {return false}
        if _storage._eventsForVersions != rhs_storage._eventsForVersions {return false}
        if _storage._firstTransactionVersion != rhs_storage._firstTransactionVersion {return false}
        if _storage._proofOfFirstTransaction != rhs_storage._proofOfFirstTransaction {return false}
        if _storage._proofOfLastTransaction != rhs_storage._proofOfLastTransaction {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
