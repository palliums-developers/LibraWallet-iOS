// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vm_errors.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) The Libra Core Contributors
// SPDX-License-Identifier: Apache-2.0

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The status of a transaction as determined by the prologue.
enum Types_VMValidationStatusCode: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// We don't want the default value to be valid
  case unknownValidationStatus // = 0

  /// The transaction has a bad signature
  case invalidSignature // = 1

  /// Bad account authentication key
  case invalidAuthKey // = 2

  /// Sequence number is too old
  case sequenceNumberTooOld // = 3

  /// Sequence number is too new
  case sequenceNumberTooNew // = 4

  /// Insufficient balance to pay minimum transaction fee
  case insufficientBalanceForTransactionFee // = 5

  /// The transaction has expired
  case transactionExpired // = 6

  /// The sending account does not exist
  case sendingAccountDoesNotExist // = 7

  /// This write set transaction was rejected because it did not meet the
  /// requirements for one.
  case rejectedWriteSet // = 8

  /// This write set transaction cannot be applied to the current state.
  case invalidWriteSet // = 9

  /// Length of program field in raw transaction exceeded max length
  case exceededMaxTransactionSize // = 10

  /// This script is not on our whitelist of script.
  case unknownScript // = 11

  /// Transaction is trying to publish a new module.
  case unknownModule // = 12

  /// Max gas units submitted with transaction exceeds max gas units bound
  /// in VM
  case maxGasUnitsExceedsMaxGasUnitsBound // = 13

  /// Max gas units submitted with transaction not enough to cover the
  /// intrinsic cost of the transaction.
  case maxGasUnitsBelowMinTransactionGasUnits // = 14

  /// Gas unit price submitted with transaction is below minimum gas price
  /// set in the VM.
  case gasUnitPriceBelowMinBound // = 15

  /// Gas unit price submitted with the transaction is above the maximum
  /// gas price set in the VM.
  case gasUnitPriceAboveMaxBound // = 16
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownValidationStatus
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownValidationStatus
    case 1: self = .invalidSignature
    case 2: self = .invalidAuthKey
    case 3: self = .sequenceNumberTooOld
    case 4: self = .sequenceNumberTooNew
    case 5: self = .insufficientBalanceForTransactionFee
    case 6: self = .transactionExpired
    case 7: self = .sendingAccountDoesNotExist
    case 8: self = .rejectedWriteSet
    case 9: self = .invalidWriteSet
    case 10: self = .exceededMaxTransactionSize
    case 11: self = .unknownScript
    case 12: self = .unknownModule
    case 13: self = .maxGasUnitsExceedsMaxGasUnitsBound
    case 14: self = .maxGasUnitsBelowMinTransactionGasUnits
    case 15: self = .gasUnitPriceBelowMinBound
    case 16: self = .gasUnitPriceAboveMaxBound
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownValidationStatus: return 0
    case .invalidSignature: return 1
    case .invalidAuthKey: return 2
    case .sequenceNumberTooOld: return 3
    case .sequenceNumberTooNew: return 4
    case .insufficientBalanceForTransactionFee: return 5
    case .transactionExpired: return 6
    case .sendingAccountDoesNotExist: return 7
    case .rejectedWriteSet: return 8
    case .invalidWriteSet: return 9
    case .exceededMaxTransactionSize: return 10
    case .unknownScript: return 11
    case .unknownModule: return 12
    case .maxGasUnitsExceedsMaxGasUnitsBound: return 13
    case .maxGasUnitsBelowMinTransactionGasUnits: return 14
    case .gasUnitPriceBelowMinBound: return 15
    case .gasUnitPriceAboveMaxBound: return 16
    case .UNRECOGNIZED(let i): return i
    }
  }

}

/// When a code module/script is published it is verified. These are the
/// possible errors that can arise from the verification process.
enum Types_VMVerificationErrorKind: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Likewise default to a unknown verification error
  case unknownVerificationError // = 0
  case indexOutOfBounds // = 1
  case codeUnitIndexOutOfBounds // = 2
  case rangeOutOfBounds // = 3
  case invalidSignatureToken // = 4
  case invalidFieldDefReference // = 5
  case recursiveStructDefinition // = 6
  case invalidResourceField // = 7
  case invalidFallThrough // = 8
  case joinFailure // = 9
  case negativeStackSizeWithinBlock // = 10
  case unbalancedStack // = 11
  case invalidMainFunctionSignature // = 12
  case duplicateElement // = 13
  case invalidModuleHandle // = 14
  case unimplementedHandle // = 15
  case inconsistentFields // = 16
  case unusedFields // = 17
  case lookupFailed // = 18
  case visibilityMismatch // = 19
  case typeResolutionFailure // = 20
  case typeMismatch // = 21
  case missingDependency // = 22
  case popReferenceError // = 23
  case popResourceError // = 24
  case releaseRefTypeMismatchError // = 25
  case brTypeMismatchError // = 26
  case abortTypeMismatchError // = 27
  case stLocTypeMismatchError // = 28
  case stLocUnsafeToDestroyError // = 29
  case retUnsafeToDestroyError // = 30
  case retTypeMismatchError // = 31
  case freezeRefTypeMismatchError // = 32
  case freezeRefExistsMutableBorrowError // = 33
  case borrowFieldTypeMismatchError // = 34
  case borrowFieldBadFieldError // = 35
  case borrowFieldExistsMutableBorrowError // = 36
  case copyLocUnavailableError // = 37
  case copyLocResourceError // = 38
  case copyLocExistsBorrowError // = 39
  case moveLocUnavailableError // = 40
  case moveLocExistsBorrowError // = 41
  case borrowLocReferenceError // = 42
  case borrowLocUnavailableError // = 43
  case borrowLocExistsBorrowError // = 44
  case callTypeMismatchError // = 45
  case callBorrowedMutableReferenceError // = 46
  case packTypeMismatchError // = 47
  case unpackTypeMismatchError // = 48
  case readRefTypeMismatchError // = 49
  case readRefResourceError // = 50
  case readRefExistsMutableBorrowError // = 51
  case writeRefTypeMismatchError // = 52
  case writeRefResourceError // = 53
  case writeRefExistsBorrowError // = 54
  case writeRefNoMutableReferenceError // = 55
  case integerOpTypeMismatchError // = 56
  case booleanOpTypeMismatchError // = 57
  case equalityOpTypeMismatchError // = 58
  case existsResourceTypeMismatchError // = 59
  case existsNoResourceError // = 60
  case borrowGlobalTypeMismatchError // = 61
  case borrowGlobalNoResourceError // = 62
  case moveFromTypeMismatchError // = 63
  case moveFromNoResourceError // = 64
  case moveToSenderTypeMismatchError // = 65
  case moveToSenderNoResourceError // = 66
  case createAccountTypeMismatchError // = 67
  case globalReferenceError // = 68

  /// The self address of a module the transaction is publishing is not the sender address
  case moduleAddressDoesNotMatchSender // = 69

  /// The module does not have any module handles. Each module or script must have at least one module handle.
  case noModuleHandles // = 70
  case missingAcquiresResourceAnnotationError // = 71
  case extraneousAcquiresResourceAnnotationError // = 72
  case duplicateAcquiresResourceAnnotationError // = 73
  case invalidAcquiresResourceAnnotationError // = 74
  case constraintKindMismatch // = 75
  case numberOfTypeActualsMismatch // = 76
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownVerificationError
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownVerificationError
    case 1: self = .indexOutOfBounds
    case 2: self = .codeUnitIndexOutOfBounds
    case 3: self = .rangeOutOfBounds
    case 4: self = .invalidSignatureToken
    case 5: self = .invalidFieldDefReference
    case 6: self = .recursiveStructDefinition
    case 7: self = .invalidResourceField
    case 8: self = .invalidFallThrough
    case 9: self = .joinFailure
    case 10: self = .negativeStackSizeWithinBlock
    case 11: self = .unbalancedStack
    case 12: self = .invalidMainFunctionSignature
    case 13: self = .duplicateElement
    case 14: self = .invalidModuleHandle
    case 15: self = .unimplementedHandle
    case 16: self = .inconsistentFields
    case 17: self = .unusedFields
    case 18: self = .lookupFailed
    case 19: self = .visibilityMismatch
    case 20: self = .typeResolutionFailure
    case 21: self = .typeMismatch
    case 22: self = .missingDependency
    case 23: self = .popReferenceError
    case 24: self = .popResourceError
    case 25: self = .releaseRefTypeMismatchError
    case 26: self = .brTypeMismatchError
    case 27: self = .abortTypeMismatchError
    case 28: self = .stLocTypeMismatchError
    case 29: self = .stLocUnsafeToDestroyError
    case 30: self = .retUnsafeToDestroyError
    case 31: self = .retTypeMismatchError
    case 32: self = .freezeRefTypeMismatchError
    case 33: self = .freezeRefExistsMutableBorrowError
    case 34: self = .borrowFieldTypeMismatchError
    case 35: self = .borrowFieldBadFieldError
    case 36: self = .borrowFieldExistsMutableBorrowError
    case 37: self = .copyLocUnavailableError
    case 38: self = .copyLocResourceError
    case 39: self = .copyLocExistsBorrowError
    case 40: self = .moveLocUnavailableError
    case 41: self = .moveLocExistsBorrowError
    case 42: self = .borrowLocReferenceError
    case 43: self = .borrowLocUnavailableError
    case 44: self = .borrowLocExistsBorrowError
    case 45: self = .callTypeMismatchError
    case 46: self = .callBorrowedMutableReferenceError
    case 47: self = .packTypeMismatchError
    case 48: self = .unpackTypeMismatchError
    case 49: self = .readRefTypeMismatchError
    case 50: self = .readRefResourceError
    case 51: self = .readRefExistsMutableBorrowError
    case 52: self = .writeRefTypeMismatchError
    case 53: self = .writeRefResourceError
    case 54: self = .writeRefExistsBorrowError
    case 55: self = .writeRefNoMutableReferenceError
    case 56: self = .integerOpTypeMismatchError
    case 57: self = .booleanOpTypeMismatchError
    case 58: self = .equalityOpTypeMismatchError
    case 59: self = .existsResourceTypeMismatchError
    case 60: self = .existsNoResourceError
    case 61: self = .borrowGlobalTypeMismatchError
    case 62: self = .borrowGlobalNoResourceError
    case 63: self = .moveFromTypeMismatchError
    case 64: self = .moveFromNoResourceError
    case 65: self = .moveToSenderTypeMismatchError
    case 66: self = .moveToSenderNoResourceError
    case 67: self = .createAccountTypeMismatchError
    case 68: self = .globalReferenceError
    case 69: self = .moduleAddressDoesNotMatchSender
    case 70: self = .noModuleHandles
    case 71: self = .missingAcquiresResourceAnnotationError
    case 72: self = .extraneousAcquiresResourceAnnotationError
    case 73: self = .duplicateAcquiresResourceAnnotationError
    case 74: self = .invalidAcquiresResourceAnnotationError
    case 75: self = .constraintKindMismatch
    case 76: self = .numberOfTypeActualsMismatch
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownVerificationError: return 0
    case .indexOutOfBounds: return 1
    case .codeUnitIndexOutOfBounds: return 2
    case .rangeOutOfBounds: return 3
    case .invalidSignatureToken: return 4
    case .invalidFieldDefReference: return 5
    case .recursiveStructDefinition: return 6
    case .invalidResourceField: return 7
    case .invalidFallThrough: return 8
    case .joinFailure: return 9
    case .negativeStackSizeWithinBlock: return 10
    case .unbalancedStack: return 11
    case .invalidMainFunctionSignature: return 12
    case .duplicateElement: return 13
    case .invalidModuleHandle: return 14
    case .unimplementedHandle: return 15
    case .inconsistentFields: return 16
    case .unusedFields: return 17
    case .lookupFailed: return 18
    case .visibilityMismatch: return 19
    case .typeResolutionFailure: return 20
    case .typeMismatch: return 21
    case .missingDependency: return 22
    case .popReferenceError: return 23
    case .popResourceError: return 24
    case .releaseRefTypeMismatchError: return 25
    case .brTypeMismatchError: return 26
    case .abortTypeMismatchError: return 27
    case .stLocTypeMismatchError: return 28
    case .stLocUnsafeToDestroyError: return 29
    case .retUnsafeToDestroyError: return 30
    case .retTypeMismatchError: return 31
    case .freezeRefTypeMismatchError: return 32
    case .freezeRefExistsMutableBorrowError: return 33
    case .borrowFieldTypeMismatchError: return 34
    case .borrowFieldBadFieldError: return 35
    case .borrowFieldExistsMutableBorrowError: return 36
    case .copyLocUnavailableError: return 37
    case .copyLocResourceError: return 38
    case .copyLocExistsBorrowError: return 39
    case .moveLocUnavailableError: return 40
    case .moveLocExistsBorrowError: return 41
    case .borrowLocReferenceError: return 42
    case .borrowLocUnavailableError: return 43
    case .borrowLocExistsBorrowError: return 44
    case .callTypeMismatchError: return 45
    case .callBorrowedMutableReferenceError: return 46
    case .packTypeMismatchError: return 47
    case .unpackTypeMismatchError: return 48
    case .readRefTypeMismatchError: return 49
    case .readRefResourceError: return 50
    case .readRefExistsMutableBorrowError: return 51
    case .writeRefTypeMismatchError: return 52
    case .writeRefResourceError: return 53
    case .writeRefExistsBorrowError: return 54
    case .writeRefNoMutableReferenceError: return 55
    case .integerOpTypeMismatchError: return 56
    case .booleanOpTypeMismatchError: return 57
    case .equalityOpTypeMismatchError: return 58
    case .existsResourceTypeMismatchError: return 59
    case .existsNoResourceError: return 60
    case .borrowGlobalTypeMismatchError: return 61
    case .borrowGlobalNoResourceError: return 62
    case .moveFromTypeMismatchError: return 63
    case .moveFromNoResourceError: return 64
    case .moveToSenderTypeMismatchError: return 65
    case .moveToSenderNoResourceError: return 66
    case .createAccountTypeMismatchError: return 67
    case .globalReferenceError: return 68
    case .moduleAddressDoesNotMatchSender: return 69
    case .noModuleHandles: return 70
    case .missingAcquiresResourceAnnotationError: return 71
    case .extraneousAcquiresResourceAnnotationError: return 72
    case .duplicateAcquiresResourceAnnotationError: return 73
    case .invalidAcquiresResourceAnnotationError: return 74
    case .constraintKindMismatch: return 75
    case .numberOfTypeActualsMismatch: return 76
    case .UNRECOGNIZED(let i): return i
    }
  }

}

/// These are errors that the VM might raise if a violation of internal
/// invariants takes place.
enum Types_VMInvariantViolationError: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownInvariantViolationError // = 0
  case outOfBoundsIndex // = 1
  case outOfBoundsRange // = 2
  case emptyValueStack // = 3
  case emptyCallStack // = 4
  case pcoverflow // = 5
  case linkerError // = 6
  case localReferenceError // = 7
  case storageError // = 8
  case internalTypeError // = 9
  case eventKeyMismatch // = 10
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownInvariantViolationError
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownInvariantViolationError
    case 1: self = .outOfBoundsIndex
    case 2: self = .outOfBoundsRange
    case 3: self = .emptyValueStack
    case 4: self = .emptyCallStack
    case 5: self = .pcoverflow
    case 6: self = .linkerError
    case 7: self = .localReferenceError
    case 8: self = .storageError
    case 9: self = .internalTypeError
    case 10: self = .eventKeyMismatch
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownInvariantViolationError: return 0
    case .outOfBoundsIndex: return 1
    case .outOfBoundsRange: return 2
    case .emptyValueStack: return 3
    case .emptyCallStack: return 4
    case .pcoverflow: return 5
    case .linkerError: return 6
    case .localReferenceError: return 7
    case .storageError: return 8
    case .internalTypeError: return 9
    case .eventKeyMismatch: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

}

/// Errors that can arise from binary decoding (deserialization)
enum Types_BinaryError: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownBinaryError // = 0
  case malformed // = 1
  case badMagic // = 2
  case unknownVersion // = 3
  case unknownTableType // = 4
  case unknownSignatureType // = 5
  case unknownSerializedType // = 6
  case unknownOpcode // = 7
  case badHeaderTable // = 8
  case unexpectedSignatureType // = 9
  case duplicateTable // = 10
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownBinaryError
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownBinaryError
    case 1: self = .malformed
    case 2: self = .badMagic
    case 3: self = .unknownVersion
    case 4: self = .unknownTableType
    case 5: self = .unknownSignatureType
    case 6: self = .unknownSerializedType
    case 7: self = .unknownOpcode
    case 8: self = .badHeaderTable
    case 9: self = .unexpectedSignatureType
    case 10: self = .duplicateTable
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownBinaryError: return 0
    case .malformed: return 1
    case .badMagic: return 2
    case .unknownVersion: return 3
    case .unknownTableType: return 4
    case .unknownSignatureType: return 5
    case .unknownSerializedType: return 6
    case .unknownOpcode: return 7
    case .badHeaderTable: return 8
    case .unexpectedSignatureType: return 9
    case .duplicateTable: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

}

enum Types_RuntimeStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownRuntimeStatus // = 0
  case executed // = 1
  case outOfGas // = 2

  /// We tried to access a resource that does not exist under the account.
  case resourceDoesNotExist // = 3

  /// We tried to create a resource under an account where that resource
  /// already exists.
  case resourceAlreadyExists // = 4

  /// We accessed an account that is evicted.
  case evictedAccountAccess // = 5

  /// We tried to create an account at an address where an account already
  /// exists.
  case accountAddressAlreadyExists // = 6
  case typeError // = 7
  case missingData // = 8
  case dataFormatError // = 9
  case invalidData // = 10
  case remoteDataError // = 11
  case cannotWriteExistingResource // = 12
  case valueSerializationError // = 13
  case valueDeserializationError // = 14

  /// The sender is trying to publish a module named `M`, but the sender's account already contains
  /// a module with this name.
  case duplicateModuleName // = 15
  case executionStackOverflow // = 16
  case callStackOverflow // = 17
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownRuntimeStatus
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownRuntimeStatus
    case 1: self = .executed
    case 2: self = .outOfGas
    case 3: self = .resourceDoesNotExist
    case 4: self = .resourceAlreadyExists
    case 5: self = .evictedAccountAccess
    case 6: self = .accountAddressAlreadyExists
    case 7: self = .typeError
    case 8: self = .missingData
    case 9: self = .dataFormatError
    case 10: self = .invalidData
    case 11: self = .remoteDataError
    case 12: self = .cannotWriteExistingResource
    case 13: self = .valueSerializationError
    case 14: self = .valueDeserializationError
    case 15: self = .duplicateModuleName
    case 16: self = .executionStackOverflow
    case 17: self = .callStackOverflow
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownRuntimeStatus: return 0
    case .executed: return 1
    case .outOfGas: return 2
    case .resourceDoesNotExist: return 3
    case .resourceAlreadyExists: return 4
    case .evictedAccountAccess: return 5
    case .accountAddressAlreadyExists: return 6
    case .typeError: return 7
    case .missingData: return 8
    case .dataFormatError: return 9
    case .invalidData: return 10
    case .remoteDataError: return 11
    case .cannotWriteExistingResource: return 12
    case .valueSerializationError: return 13
    case .valueDeserializationError: return 14
    case .duplicateModuleName: return 15
    case .executionStackOverflow: return 16
    case .callStackOverflow: return 17
    case .UNRECOGNIZED(let i): return i
    }
  }

}

struct Types_VMValidationStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: Types_VMValidationStatusCode = .unknownValidationStatus

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_VMVerificationStatusList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var statusList: [Types_VMVerificationStatus] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_VMVerificationStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var statusKind: Types_VMVerificationStatus.StatusKind {
    get {return _storage._statusKind}
    set {_uniqueStorage()._statusKind = newValue}
  }

  /// For StatusKind::SCRIPT and DEPENDENCY this is ignored.
  var moduleIdx: UInt32 {
    get {return _storage._moduleIdx}
    set {_uniqueStorage()._moduleIdx = newValue}
  }

  var errorKind: Types_VMVerificationErrorKind {
    get {return _storage._errorKind}
    set {_uniqueStorage()._errorKind = newValue}
  }

  var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  /// For StatusKind::SCRIPT and MODULE this is ignored.
  var dependencyID: Types_ModuleId {
    get {return _storage._dependencyID ?? Types_ModuleId()}
    set {_uniqueStorage()._dependencyID = newValue}
  }
  /// Returns true if `dependencyID` has been explicitly set.
  var hasDependencyID: Bool {return _storage._dependencyID != nil}
  /// Clears the value of `dependencyID`. Subsequent reads from it will return its default value.
  mutating func clearDependencyID() {_storage._dependencyID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum StatusKind: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case script // = 0
    case module // = 1
    case dependency // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .script
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .script
      case 1: self = .module
      case 2: self = .dependency
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .script: return 0
      case .module: return 1
      case .dependency: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// user-defined abort error code number
struct Types_Aborted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var abortedErrorCode: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_ArithmeticError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorCode: Types_ArithmeticError.ArithmeticErrorType = .unknownArithmeticError

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ArithmeticErrorType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknownArithmeticError // = 0
    case underflow // = 1
    case overflow // = 2

    /// Fill with more later
    case divisionByZero // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unknownArithmeticError
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownArithmeticError
      case 1: self = .underflow
      case 2: self = .overflow
      case 3: self = .divisionByZero
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownArithmeticError: return 0
      case .underflow: return 1
      case .overflow: return 2
      case .divisionByZero: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

struct Types_DynamicReferenceError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorCode: Types_DynamicReferenceError.DynamicReferenceErrorType = .unknownDynamicReferenceError

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum DynamicReferenceErrorType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknownDynamicReferenceError // = 0
    case moveOfBorrowedResource // = 1
    case globalRefAlreadyReleased // = 2
    case missingReleaseRef // = 3

    /// Fill with with more later
    case globalAlreadyBorrowed // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .unknownDynamicReferenceError
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownDynamicReferenceError
      case 1: self = .moveOfBorrowedResource
      case 2: self = .globalRefAlreadyReleased
      case 3: self = .missingReleaseRef
      case 4: self = .globalAlreadyBorrowed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownDynamicReferenceError: return 0
      case .moveOfBorrowedResource: return 1
      case .globalRefAlreadyReleased: return 2
      case .missingReleaseRef: return 3
      case .globalAlreadyBorrowed: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

struct Types_ExecutionStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var executionStatus: OneOf_ExecutionStatus? {
    get {return _storage._executionStatus}
    set {_uniqueStorage()._executionStatus = newValue}
  }

  var runtimeStatus: Types_RuntimeStatus {
    get {
      if case .runtimeStatus(let v)? = _storage._executionStatus {return v}
      return .unknownRuntimeStatus
    }
    set {_uniqueStorage()._executionStatus = .runtimeStatus(newValue)}
  }

  var aborted: Types_Aborted {
    get {
      if case .aborted(let v)? = _storage._executionStatus {return v}
      return Types_Aborted()
    }
    set {_uniqueStorage()._executionStatus = .aborted(newValue)}
  }

  var arithmeticError: Types_ArithmeticError {
    get {
      if case .arithmeticError(let v)? = _storage._executionStatus {return v}
      return Types_ArithmeticError()
    }
    set {_uniqueStorage()._executionStatus = .arithmeticError(newValue)}
  }

  var referenceError: Types_DynamicReferenceError {
    get {
      if case .referenceError(let v)? = _storage._executionStatus {return v}
      return Types_DynamicReferenceError()
    }
    set {_uniqueStorage()._executionStatus = .referenceError(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ExecutionStatus: Equatable {
    case runtimeStatus(Types_RuntimeStatus)
    case aborted(Types_Aborted)
    case arithmeticError(Types_ArithmeticError)
    case referenceError(Types_DynamicReferenceError)

    static func ==(lhs: Types_ExecutionStatus.OneOf_ExecutionStatus, rhs: Types_ExecutionStatus.OneOf_ExecutionStatus) -> Bool {
      switch (lhs, rhs) {
      case (.runtimeStatus(let l), .runtimeStatus(let r)): return l == r
      case (.aborted(let l), .aborted(let r)): return l == r
      case (.arithmeticError(let l), .arithmeticError(let r)): return l == r
      case (.referenceError(let l), .referenceError(let r)): return l == r
      default: return false
      }
    }
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The status of the VM
struct Types_VMStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorType: OneOf_ErrorType? {
    get {return _storage._errorType}
    set {_uniqueStorage()._errorType = newValue}
  }

  var validation: Types_VMValidationStatus {
    get {
      if case .validation(let v)? = _storage._errorType {return v}
      return Types_VMValidationStatus()
    }
    set {_uniqueStorage()._errorType = .validation(newValue)}
  }

  var verification: Types_VMVerificationStatusList {
    get {
      if case .verification(let v)? = _storage._errorType {return v}
      return Types_VMVerificationStatusList()
    }
    set {_uniqueStorage()._errorType = .verification(newValue)}
  }

  var invariantViolation: Types_VMInvariantViolationError {
    get {
      if case .invariantViolation(let v)? = _storage._errorType {return v}
      return .unknownInvariantViolationError
    }
    set {_uniqueStorage()._errorType = .invariantViolation(newValue)}
  }

  var deserialization: Types_BinaryError {
    get {
      if case .deserialization(let v)? = _storage._errorType {return v}
      return .unknownBinaryError
    }
    set {_uniqueStorage()._errorType = .deserialization(newValue)}
  }

  var execution: Types_ExecutionStatus {
    get {
      if case .execution(let v)? = _storage._errorType {return v}
      return Types_ExecutionStatus()
    }
    set {_uniqueStorage()._errorType = .execution(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ErrorType: Equatable {
    case validation(Types_VMValidationStatus)
    case verification(Types_VMVerificationStatusList)
    case invariantViolation(Types_VMInvariantViolationError)
    case deserialization(Types_BinaryError)
    case execution(Types_ExecutionStatus)

    static func ==(lhs: Types_VMStatus.OneOf_ErrorType, rhs: Types_VMStatus.OneOf_ErrorType) -> Bool {
      switch (lhs, rhs) {
      case (.validation(let l), .validation(let r)): return l == r
      case (.verification(let l), .verification(let r)): return l == r
      case (.invariantViolation(let l), .invariantViolation(let r)): return l == r
      case (.deserialization(let l), .deserialization(let r)): return l == r
      case (.execution(let l), .execution(let r)): return l == r
      default: return false
      }
    }
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "types"

extension Types_VMValidationStatusCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UnknownValidationStatus"),
    1: .same(proto: "InvalidSignature"),
    2: .same(proto: "InvalidAuthKey"),
    3: .same(proto: "SequenceNumberTooOld"),
    4: .same(proto: "SequenceNumberTooNew"),
    5: .same(proto: "InsufficientBalanceForTransactionFee"),
    6: .same(proto: "TransactionExpired"),
    7: .same(proto: "SendingAccountDoesNotExist"),
    8: .same(proto: "RejectedWriteSet"),
    9: .same(proto: "InvalidWriteSet"),
    10: .same(proto: "ExceededMaxTransactionSize"),
    11: .same(proto: "UnknownScript"),
    12: .same(proto: "UnknownModule"),
    13: .same(proto: "MaxGasUnitsExceedsMaxGasUnitsBound"),
    14: .same(proto: "MaxGasUnitsBelowMinTransactionGasUnits"),
    15: .same(proto: "GasUnitPriceBelowMinBound"),
    16: .same(proto: "GasUnitPriceAboveMaxBound"),
  ]
}

extension Types_VMVerificationErrorKind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UnknownVerificationError"),
    1: .same(proto: "IndexOutOfBounds"),
    2: .same(proto: "CodeUnitIndexOutOfBounds"),
    3: .same(proto: "RangeOutOfBounds"),
    4: .same(proto: "InvalidSignatureToken"),
    5: .same(proto: "InvalidFieldDefReference"),
    6: .same(proto: "RecursiveStructDefinition"),
    7: .same(proto: "InvalidResourceField"),
    8: .same(proto: "InvalidFallThrough"),
    9: .same(proto: "JoinFailure"),
    10: .same(proto: "NegativeStackSizeWithinBlock"),
    11: .same(proto: "UnbalancedStack"),
    12: .same(proto: "InvalidMainFunctionSignature"),
    13: .same(proto: "DuplicateElement"),
    14: .same(proto: "InvalidModuleHandle"),
    15: .same(proto: "UnimplementedHandle"),
    16: .same(proto: "InconsistentFields"),
    17: .same(proto: "UnusedFields"),
    18: .same(proto: "LookupFailed"),
    19: .same(proto: "VisibilityMismatch"),
    20: .same(proto: "TypeResolutionFailure"),
    21: .same(proto: "TypeMismatch"),
    22: .same(proto: "MissingDependency"),
    23: .same(proto: "PopReferenceError"),
    24: .same(proto: "PopResourceError"),
    25: .same(proto: "ReleaseRefTypeMismatchError"),
    26: .same(proto: "BrTypeMismatchError"),
    27: .same(proto: "AbortTypeMismatchError"),
    28: .same(proto: "StLocTypeMismatchError"),
    29: .same(proto: "StLocUnsafeToDestroyError"),
    30: .same(proto: "RetUnsafeToDestroyError"),
    31: .same(proto: "RetTypeMismatchError"),
    32: .same(proto: "FreezeRefTypeMismatchError"),
    33: .same(proto: "FreezeRefExistsMutableBorrowError"),
    34: .same(proto: "BorrowFieldTypeMismatchError"),
    35: .same(proto: "BorrowFieldBadFieldError"),
    36: .same(proto: "BorrowFieldExistsMutableBorrowError"),
    37: .same(proto: "CopyLocUnavailableError"),
    38: .same(proto: "CopyLocResourceError"),
    39: .same(proto: "CopyLocExistsBorrowError"),
    40: .same(proto: "MoveLocUnavailableError"),
    41: .same(proto: "MoveLocExistsBorrowError"),
    42: .same(proto: "BorrowLocReferenceError"),
    43: .same(proto: "BorrowLocUnavailableError"),
    44: .same(proto: "BorrowLocExistsBorrowError"),
    45: .same(proto: "CallTypeMismatchError"),
    46: .same(proto: "CallBorrowedMutableReferenceError"),
    47: .same(proto: "PackTypeMismatchError"),
    48: .same(proto: "UnpackTypeMismatchError"),
    49: .same(proto: "ReadRefTypeMismatchError"),
    50: .same(proto: "ReadRefResourceError"),
    51: .same(proto: "ReadRefExistsMutableBorrowError"),
    52: .same(proto: "WriteRefTypeMismatchError"),
    53: .same(proto: "WriteRefResourceError"),
    54: .same(proto: "WriteRefExistsBorrowError"),
    55: .same(proto: "WriteRefNoMutableReferenceError"),
    56: .same(proto: "IntegerOpTypeMismatchError"),
    57: .same(proto: "BooleanOpTypeMismatchError"),
    58: .same(proto: "EqualityOpTypeMismatchError"),
    59: .same(proto: "ExistsResourceTypeMismatchError"),
    60: .same(proto: "ExistsNoResourceError"),
    61: .same(proto: "BorrowGlobalTypeMismatchError"),
    62: .same(proto: "BorrowGlobalNoResourceError"),
    63: .same(proto: "MoveFromTypeMismatchError"),
    64: .same(proto: "MoveFromNoResourceError"),
    65: .same(proto: "MoveToSenderTypeMismatchError"),
    66: .same(proto: "MoveToSenderNoResourceError"),
    67: .same(proto: "CreateAccountTypeMismatchError"),
    68: .same(proto: "GlobalReferenceError"),
    69: .same(proto: "ModuleAddressDoesNotMatchSender"),
    70: .same(proto: "NoModuleHandles"),
    71: .same(proto: "MissingAcquiresResourceAnnotationError"),
    72: .same(proto: "ExtraneousAcquiresResourceAnnotationError"),
    73: .same(proto: "DuplicateAcquiresResourceAnnotationError"),
    74: .same(proto: "InvalidAcquiresResourceAnnotationError"),
    75: .same(proto: "ConstraintKindMismatch"),
    76: .same(proto: "NumberOfTypeActualsMismatch"),
  ]
}

extension Types_VMInvariantViolationError: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UnknownInvariantViolationError"),
    1: .same(proto: "OutOfBoundsIndex"),
    2: .same(proto: "OutOfBoundsRange"),
    3: .same(proto: "EmptyValueStack"),
    4: .same(proto: "EmptyCallStack"),
    5: .same(proto: "PCOverflow"),
    6: .same(proto: "LinkerError"),
    7: .same(proto: "LocalReferenceError"),
    8: .same(proto: "StorageError"),
    9: .same(proto: "InternalTypeError"),
    10: .same(proto: "EventKeyMismatch"),
  ]
}

extension Types_BinaryError: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UnknownBinaryError"),
    1: .same(proto: "Malformed"),
    2: .same(proto: "BadMagic"),
    3: .same(proto: "UnknownVersion"),
    4: .same(proto: "UnknownTableType"),
    5: .same(proto: "UnknownSignatureType"),
    6: .same(proto: "UnknownSerializedType"),
    7: .same(proto: "UnknownOpcode"),
    8: .same(proto: "BadHeaderTable"),
    9: .same(proto: "UnexpectedSignatureType"),
    10: .same(proto: "DuplicateTable"),
  ]
}

extension Types_RuntimeStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UnknownRuntimeStatus"),
    1: .same(proto: "Executed"),
    2: .same(proto: "OutOfGas"),
    3: .same(proto: "ResourceDoesNotExist"),
    4: .same(proto: "ResourceAlreadyExists"),
    5: .same(proto: "EvictedAccountAccess"),
    6: .same(proto: "AccountAddressAlreadyExists"),
    7: .same(proto: "TypeError"),
    8: .same(proto: "MissingData"),
    9: .same(proto: "DataFormatError"),
    10: .same(proto: "InvalidData"),
    11: .same(proto: "RemoteDataError"),
    12: .same(proto: "CannotWriteExistingResource"),
    13: .same(proto: "ValueSerializationError"),
    14: .same(proto: "ValueDeserializationError"),
    15: .same(proto: "DuplicateModuleName"),
    16: .same(proto: "ExecutionStackOverflow"),
    17: .same(proto: "CallStackOverflow"),
  ]
}

extension Types_VMValidationStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VMValidationStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      case 2: try decoder.decodeSingularStringField(value: &self.message)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .unknownValidationStatus {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Types_VMValidationStatus) -> Bool {
    if self.code != other.code {return false}
    if self.message != other.message {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Types_VMVerificationStatusList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VMVerificationStatusList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "status_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.statusList)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.statusList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.statusList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Types_VMVerificationStatusList) -> Bool {
    if self.statusList != other.statusList {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Types_VMVerificationStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VMVerificationStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "status_kind"),
    2: .standard(proto: "module_idx"),
    3: .standard(proto: "error_kind"),
    4: .same(proto: "message"),
    5: .standard(proto: "dependency_id"),
  ]

  fileprivate class _StorageClass {
    var _statusKind: Types_VMVerificationStatus.StatusKind = .script
    var _moduleIdx: UInt32 = 0
    var _errorKind: Types_VMVerificationErrorKind = .unknownVerificationError
    var _message: String = String()
    var _dependencyID: Types_ModuleId? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _statusKind = source._statusKind
      _moduleIdx = source._moduleIdx
      _errorKind = source._errorKind
      _message = source._message
      _dependencyID = source._dependencyID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._statusKind)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._moduleIdx)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._errorKind)
        case 4: try decoder.decodeSingularStringField(value: &_storage._message)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._dependencyID)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._statusKind != .script {
        try visitor.visitSingularEnumField(value: _storage._statusKind, fieldNumber: 1)
      }
      if _storage._moduleIdx != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._moduleIdx, fieldNumber: 2)
      }
      if _storage._errorKind != .unknownVerificationError {
        try visitor.visitSingularEnumField(value: _storage._errorKind, fieldNumber: 3)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 4)
      }
      if let v = _storage._dependencyID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Types_VMVerificationStatus) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._statusKind != other_storage._statusKind {return false}
        if _storage._moduleIdx != other_storage._moduleIdx {return false}
        if _storage._errorKind != other_storage._errorKind {return false}
        if _storage._message != other_storage._message {return false}
        if _storage._dependencyID != other_storage._dependencyID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Types_VMVerificationStatus.StatusKind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SCRIPT"),
    1: .same(proto: "MODULE"),
    2: .same(proto: "DEPENDENCY"),
  ]
}

extension Types_Aborted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Aborted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "aborted_error_code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.abortedErrorCode)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.abortedErrorCode != 0 {
      try visitor.visitSingularUInt64Field(value: self.abortedErrorCode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Types_Aborted) -> Bool {
    if self.abortedErrorCode != other.abortedErrorCode {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Types_ArithmeticError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ArithmeticError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.errorCode)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .unknownArithmeticError {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Types_ArithmeticError) -> Bool {
    if self.errorCode != other.errorCode {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Types_ArithmeticError.ArithmeticErrorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UnknownArithmeticError"),
    1: .same(proto: "Underflow"),
    2: .same(proto: "Overflow"),
    3: .same(proto: "DivisionByZero"),
  ]
}

extension Types_DynamicReferenceError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DynamicReferenceError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.errorCode)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .unknownDynamicReferenceError {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Types_DynamicReferenceError) -> Bool {
    if self.errorCode != other.errorCode {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Types_DynamicReferenceError.DynamicReferenceErrorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UnknownDynamicReferenceError"),
    1: .same(proto: "MoveOfBorrowedResource"),
    2: .same(proto: "GlobalRefAlreadyReleased"),
    3: .same(proto: "MissingReleaseRef"),
    4: .same(proto: "GlobalAlreadyBorrowed"),
  ]
}

extension Types_ExecutionStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecutionStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "runtime_status"),
    2: .same(proto: "aborted"),
    3: .standard(proto: "arithmetic_error"),
    4: .standard(proto: "reference_error"),
  ]

  fileprivate class _StorageClass {
    var _executionStatus: Types_ExecutionStatus.OneOf_ExecutionStatus?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _executionStatus = source._executionStatus
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._executionStatus != nil {try decoder.handleConflictingOneOf()}
          var v: Types_RuntimeStatus?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {_storage._executionStatus = .runtimeStatus(v)}
        case 2:
          var v: Types_Aborted?
          if let current = _storage._executionStatus {
            try decoder.handleConflictingOneOf()
            if case .aborted(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._executionStatus = .aborted(v)}
        case 3:
          var v: Types_ArithmeticError?
          if let current = _storage._executionStatus {
            try decoder.handleConflictingOneOf()
            if case .arithmeticError(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._executionStatus = .arithmeticError(v)}
        case 4:
          var v: Types_DynamicReferenceError?
          if let current = _storage._executionStatus {
            try decoder.handleConflictingOneOf()
            if case .referenceError(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._executionStatus = .referenceError(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._executionStatus {
      case .runtimeStatus(let v)?:
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      case .aborted(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .arithmeticError(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .referenceError(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Types_ExecutionStatus) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._executionStatus != other_storage._executionStatus {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Types_VMStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VMStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "validation"),
    2: .same(proto: "verification"),
    3: .standard(proto: "invariant_violation"),
    4: .same(proto: "deserialization"),
    5: .same(proto: "execution"),
  ]

  fileprivate class _StorageClass {
    var _errorType: Types_VMStatus.OneOf_ErrorType?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _errorType = source._errorType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Types_VMValidationStatus?
          if let current = _storage._errorType {
            try decoder.handleConflictingOneOf()
            if case .validation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._errorType = .validation(v)}
        case 2:
          var v: Types_VMVerificationStatusList?
          if let current = _storage._errorType {
            try decoder.handleConflictingOneOf()
            if case .verification(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._errorType = .verification(v)}
        case 3:
          if _storage._errorType != nil {try decoder.handleConflictingOneOf()}
          var v: Types_VMInvariantViolationError?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {_storage._errorType = .invariantViolation(v)}
        case 4:
          if _storage._errorType != nil {try decoder.handleConflictingOneOf()}
          var v: Types_BinaryError?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {_storage._errorType = .deserialization(v)}
        case 5:
          var v: Types_ExecutionStatus?
          if let current = _storage._errorType {
            try decoder.handleConflictingOneOf()
            if case .execution(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._errorType = .execution(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._errorType {
      case .validation(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .verification(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .invariantViolation(let v)?:
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      case .deserialization(let v)?:
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      case .execution(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Types_VMStatus) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._errorType != other_storage._errorType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
